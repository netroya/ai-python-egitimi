<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python ile Blockchain ve Web3 GeliÅŸtirme: 2025 KapsamlÄ± Rehberi | AI & Python</title>
    <meta name="description" content="Python ile blockchain ve Web3 geliÅŸtirme Ã¶ÄŸrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± keÅŸfedin.">
    <meta name="keywords" content="python blockchain, web3 python, smart contract python, defi python, nft python, kripto para python, ethereum python, solidity python">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Python ile Blockchain ve Web3 GeliÅŸtirme: 2025 KapsamlÄ± Rehberi">
    <meta property="og:description" content="Python ile blockchain ve Web3 geliÅŸtirme Ã¶ÄŸrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± keÅŸfedin.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://netroya.github.io/ai-python-egitimi/blog/python/python-ile-blockchain-web3-gelistirme-2025-rehberi.html">
    
    <!-- Schema.org -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Python ile Blockchain ve Web3 GeliÅŸtirme: 2025 KapsamlÄ± Rehberi",
        "description": "Python ile blockchain ve Web3 geliÅŸtirme Ã¶ÄŸrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± keÅŸfedin.",
        "author": {
            "@type": "Organization",
            "name": "AI & Python EÄŸitimi"
        },
        "datePublished": "2025-08-20",
        "dateModified": "2025-08-20"
    }
    </script>
    
    <link rel="stylesheet" href="../blog-styles.css">
    <link rel="canonical" href="https://netroya.github.io/ai-python-egitimi/blog/python/python-ile-blockchain-web3-gelistirme-2025-rehberi.html">
    
    <!-- AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9023802833968711" crossorigin="anonymous"></script>
</head>
<body>
    <!-- Header Ad Zone -->
    <div class="ad-zone-header">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="3838714977" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="../../index.html" class="nav-logo">
                <span class="logo-text">PyCode Academy</span>
            </a>
            <div class="nav-menu">
                <a href="../../index.html" class="nav-link">Ana Sayfa</a>
                <a href="../index.html" class="nav-link">Blog</a>
                <a href="index.html" class="nav-link">Python</a>
                <a href="../ai-ml/index.html" class="nav-link">AI & ML</a>
                <a href="../career/index.html" class="nav-link">Kariyer</a>
                <a href="../web-dev/index.html" class="nav-link">Web Dev</a>
            </div>
        </div>
    </nav>

    <main class="blog-container">
        <article class="blog-post">
            <!-- Article Header -->
            <header class="article-header">
                <div class="breadcrumb">
                    <a href="../../index.html">Ana Sayfa</a> > 
                    <a href="../index.html">Blog</a> > 
                    <a href="index.html">Python</a> > 
                    <span>Blockchain & Web3</span>
                </div>
                
                <div class="article-meta">
                    <span class="category blockchain">ğŸ”— Blockchain</span>
                    <span class="category web3">ğŸŒ Web3</span>
                    <span class="read-time">â±ï¸ 15 dakika okuma</span>
                    <span class="publish-date">ğŸ“… 20 AÄŸustos 2025</span>
                    <span class="trend-badge">ğŸ”¥ TREND</span>
                </div>
                
                <h1>ğŸš€ Python ile Blockchain ve Web3 GeliÅŸtirme: 2025 KapsamlÄ± Rehberi</h1>
                
                <div class="article-intro">
                    <p class="lead">Blockchain teknolojisi ve Web3 dÃ¼nyasÄ± hÄ±zla geliÅŸiyor. Python'un gÃ¼Ã§lÃ¼ kÃ¼tÃ¼phaneleri ve basit sÃ¶zdizimi sayesinde blockchain geliÅŸtirme hiÃ§ bu kadar kolay olmamÄ±ÅŸtÄ±. Bu kapsamlÄ± rehberde, Python ile smart contract'lardan DeFi uygulamalarÄ±na, NFT projelerinden kripto para botlarÄ±na kadar her ÅŸeyi Ã¶ÄŸreneceksiniz.</p>
                </div>
                
                <div class="article-highlights">
                    <h3>ğŸ“‹ Bu Makalede Ã–ÄŸrenecekleriniz:</h3>
                    <ul>
                        <li>âœ… Python ile blockchain temellerini anlama</li>
                        <li>âœ… Web3.py ile Ethereum blockchain'e baÄŸlanma</li>
                        <li>âœ… Smart contract geliÅŸtirme ve deploy etme</li>
                        <li>âœ… DeFi protokolleri ile etkileÅŸim kurma</li>
                        <li>âœ… NFT minting ve trading botlarÄ±</li>
                        <li>âœ… Kripto para arbitraj botlarÄ±</li>
                        <li>âœ… Blockchain veri analizi</li>
                        <li>âœ… GÃ¼venlik en iyi uygulamalarÄ±</li>
                    </ul>
                </div>
            </header>

            <!-- Table of Contents -->
            <div class="table-of-contents">
                <h3>ğŸ“– Ä°Ã§indekiler</h3>
                <ol>
                    <li><a href="#blockchain-temelleri">Blockchain ve Web3 Temelleri</a></li>
                    <li><a href="#python-kurulum">Python GeliÅŸtirme OrtamÄ± Kurulumu</a></li>
                    <li><a href="#web3py-baslangic">Web3.py ile Ä°lk AdÄ±mlar</a></li>
                    <li><a href="#smart-contracts">Smart Contract GeliÅŸtirme</a></li>
                    <li><a href="#defi-uygulamalari">DeFi UygulamalarÄ±</a></li>
                    <li><a href="#nft-projeleri">NFT Projeleri</a></li>
                    <li><a href="#trading-botlari">Trading ve Arbitraj BotlarÄ±</a></li>
                    <li><a href="#veri-analizi">Blockchain Veri Analizi</a></li>
                    <li><a href="#guvenlik">GÃ¼venlik ve En Ä°yi Uygulamalar</a></li>
                    <li><a href="#gelecek-trendler">2025 Trendleri ve Gelecek</a></li>
                </ol>
            </div>

            <!-- Mid-Content Ad -->
            <div class="ad-zone-content">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9023802833968711" data-ad-slot="4515379030"></ins>
                <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>

            <!-- Article Content -->
            <div class="article-content">
                <section id="blockchain-temelleri">
                    <h2>ğŸ§± 1. Blockchain ve Web3 Temelleri</h2>
                    
                    <h3>Blockchain Nedir?</h3>
                    <p>Blockchain, verilerin bloklar halinde zincir ÅŸeklinde saklandÄ±ÄŸÄ± daÄŸÄ±tÄ±lmÄ±ÅŸ bir veritabanÄ± teknolojisidir. Her blok, Ã¶nceki bloÄŸa kriptografik hash ile baÄŸlÄ±dÄ±r ve bu sayede deÄŸiÅŸtirilemez bir kayÄ±t oluÅŸturur.</p>
                    
                    <div class="info-box">
                        <h4>ğŸ”‘ Blockchain'in Temel Ã–zellikleri:</h4>
                        <ul>
                            <li><strong>Merkeziyetsizlik:</strong> Tek bir otoritenin kontrolÃ¼ yoktur</li>
                            <li><strong>ÅeffaflÄ±k:</strong> TÃ¼m iÅŸlemler herkese aÃ§Ä±k gÃ¶rÃ¼lebilir</li>
                            <li><strong>DeÄŸiÅŸtirilemezlik:</strong> OnaylanmÄ±ÅŸ iÅŸlemler deÄŸiÅŸtirilemez</li>
                            <li><strong>GÃ¼venlik:</strong> Kriptografik koruma</li>
                        </ul>
                    </div>
                    
                    <h3>Web3 Nedir?</h3>
                    <p>Web3, internetin yeni nesli olarak tanÄ±mlanan ve blockchain teknolojisi Ã¼zerine inÅŸa edilen merkeziyetsiz web vizyonudur. KullanÄ±cÄ±larÄ±n verilerine sahip olduÄŸu ve aracÄ±lar olmadan etkileÅŸim kurabildiÄŸi bir internet.</p>
                    
                    <div class="code-example">
                        <h4>ğŸ’¡ Web1 vs Web2 vs Web3 KarÅŸÄ±laÅŸtÄ±rmasÄ±</h4>
                        <pre><code># Web1: Sadece Okuma (1990-2004)
# - Statik web sayfalarÄ±
# - Tek yÃ¶nlÃ¼ iletiÅŸim
# - HTML tabanlÄ±

# Web2: Okuma + Yazma (2004-gÃ¼nÃ¼mÃ¼z)
# - Sosyal medya platformlarÄ±
# - KullanÄ±cÄ± Ã¼retimi iÃ§erik
# - Merkezi platformlar

# Web3: Okuma + Yazma + Sahiplik (2020+)
# - Merkeziyetsiz uygulamalar (dApps)
# - KullanÄ±cÄ± veri sahipliÄŸi
# - Blockchain tabanlÄ±</code></pre>
                    </div>
                </section>

                <section id="python-kurulum">
                    <h2>âš™ï¸ 2. Python GeliÅŸtirme OrtamÄ± Kurulumu</h2>
                    
                    <h3>Gerekli KÃ¼tÃ¼phaneler</h3>
                    <p>Python ile blockchain geliÅŸtirme iÃ§in aÅŸaÄŸÄ±daki kÃ¼tÃ¼phaneleri kurmanÄ±z gerekiyor:</p>
                    
                    <div class="code-example">
                        <pre><code># Temel Web3 kÃ¼tÃ¼phaneleri
pip install web3
pip install eth-account
pip install brownie-eth

# Blockchain veri analizi
pip install pandas
pip install matplotlib
pip install seaborn

# API ve HTTP istekleri
pip install requests
pip install aiohttp

# Matematiksel hesaplamalar
pip install numpy
pip install scipy

# Asenkron programlama
pip install asyncio
pip install websockets</code></pre>
                    </div>
                    
                    <h3>Development Environment Setup</h3>
                    <div class="code-example">
                        <pre><code>from web3 import Web3
import json
import asyncio
from eth_account import Account
import pandas as pd

# Infura veya Alchemy endpoint
INFURA_URL = "https://mainnet.infura.io/v3/YOUR_PROJECT_ID"
w3 = Web3(Web3.HTTPProvider(INFURA_URL))

# BaÄŸlantÄ± testi
if w3.is_connected():
    print("âœ… Ethereum aÄŸÄ±na baÅŸarÄ±yla baÄŸlandÄ±")
    print(f"En son blok numarasÄ±: {w3.eth.block_number}")
else:
    print("âŒ BaÄŸlantÄ± hatasÄ±")</code></pre>
                    </div>
                </section>

                <section id="web3py-baslangic">
                    <h2>ğŸŒ 3. Web3.py ile Ä°lk AdÄ±mlar</h2>
                    
                    <h3>Ethereum AÄŸÄ±na BaÄŸlanma</h3>
                    <div class="code-example">
                        <pre><code>from web3 import Web3

class EthereumConnector:
    def __init__(self, provider_url):
        self.w3 = Web3(Web3.HTTPProvider(provider_url))
        
    def get_balance(self, address):
        """Adres bakiyesini ETH cinsinden dÃ¶ndÃ¼r"""
        balance_wei = self.w3.eth.get_balance(address)
        balance_eth = self.w3.from_wei(balance_wei, 'ether')
        return float(balance_eth)
    
    def get_gas_price(self):
        """GÃ¼ncel gas fiyatÄ±nÄ± Gwei cinsinden dÃ¶ndÃ¼r"""
        gas_price_wei = self.w3.eth.gas_price
        gas_price_gwei = self.w3.from_wei(gas_price_wei, 'gwei')
        return float(gas_price_gwei)
    
    def get_transaction(self, tx_hash):
        """Ä°ÅŸlem detaylarÄ±nÄ± getir"""
        try:
            return self.w3.eth.get_transaction(tx_hash)
        except Exception as e:
            print(f"Ä°ÅŸlem bulunamadÄ±: {e}")
            return None

# KullanÄ±m
eth = EthereumConnector("https://mainnet.infura.io/v3/YOUR_PROJECT_ID")
vitalik_address = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"
balance = eth.get_balance(vitalik_address)
print(f"Vitalik'in bakiyesi: {balance:.4f} ETH")</code></pre>
                    </div>
                    
                    <h3>CÃ¼zdan Ä°ÅŸlemleri</h3>
                    <div class="code-example">
                        <pre><code>from eth_account import Account
import secrets

class WalletManager:
    def __init__(self):
        self.accounts = {}
    
    def create_wallet(self, name):
        """Yeni cÃ¼zdan oluÅŸtur"""
        # GÃ¼venli private key oluÅŸtur
        private_key = "0x" + secrets.token_hex(32)
        account = Account.from_key(private_key)
        
        wallet_info = {
            'address': account.address,
            'private_key': private_key,
            'public_key': account.key.hex()
        }
        
        self.accounts[name] = wallet_info
        return wallet_info
    
    def sign_transaction(self, account_name, transaction):
        """Ä°ÅŸlemi imzala"""
        if account_name not in self.accounts:
            raise ValueError("Hesap bulunamadÄ±")
        
        private_key = self.accounts[account_name]['private_key']
        signed_txn = Account.sign_transaction(transaction, private_key)
        return signed_txn
    
    def export_wallet(self, account_name, password):
        """CÃ¼zdanÄ± JSON formatÄ±nda dÄ±ÅŸa aktar"""
        if account_name not in self.accounts:
            raise ValueError("Hesap bulunamadÄ±")
        
        private_key = self.accounts[account_name]['private_key']
        encrypted = Account.encrypt(private_key, password)
        return encrypted

# KullanÄ±m
wallet_manager = WalletManager()
new_wallet = wallet_manager.create_wallet("my_wallet")
print(f"Yeni cÃ¼zdan adresi: {new_wallet['address']}")</code></pre>
                    </div>
                </section>

                <section id="smart-contracts">
                    <h2>ğŸ“„ 4. Smart Contract GeliÅŸtirme</h2>
                    
                    <h3>Solidity ile Smart Contract</h3>
                    <p>Ã–nce basit bir ERC-20 token contract'Ä± yazalÄ±m:</p>
                    
                    <div class="code-example">
                        <h4>ğŸ”— SimpleToken.sol</h4>
                        <pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    string public name = "PyToken";
    string public symbol = "PYT";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10**decimals;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}</code></pre>
                    </div>
                    
                    <h3>Python ile Smart Contract EtkileÅŸimi</h3>
                    <div class="code-example">
                        <pre><code>import json
from web3 import Web3

class SmartContractManager:
    def __init__(self, w3, contract_address, abi):
        self.w3 = w3
        self.contract = w3.eth.contract(address=contract_address, abi=abi)
    
    def read_function(self, function_name, *args):
        """Smart contract okuma fonksiyonu Ã§aÄŸÄ±r"""
        try:
            function = getattr(self.contract.functions, function_name)
            result = function(*args).call()
            return result
        except Exception as e:
            print(f"Okuma hatasÄ±: {e}")
            return None
    
    def write_function(self, function_name, private_key, *args, **kwargs):
        """Smart contract yazma fonksiyonu Ã§aÄŸÄ±r"""
        try:
            # Account bilgilerini al
            account = Account.from_key(private_key)
            
            # Fonksiyonu hazÄ±rla
            function = getattr(self.contract.functions, function_name)
            
            # Ä°ÅŸlem parametreleri
            transaction = function(*args).build_transaction({
                'from': account.address,
                'gas': kwargs.get('gas', 200000),
                'gasPrice': self.w3.to_wei(kwargs.get('gas_price', 20), 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(account.address),
            })
            
            # Ä°ÅŸlemi imzala ve gÃ¶nder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            return tx_hash.hex()
            
        except Exception as e:
            print(f"Yazma hatasÄ±: {e}")
            return None
    
    def get_events(self, event_name, from_block=0, to_block='latest'):
        """Contract event'lerini getir"""
        try:
            event_filter = getattr(self.contract.events, event_name).create_filter(
                fromBlock=from_block, 
                toBlock=to_block
            )
            return event_filter.get_all_entries()
        except Exception as e:
            print(f"Event okuma hatasÄ±: {e}")
            return []

# ERC-20 Token yÃ¶netimi Ã¶rneÄŸi
class TokenManager(SmartContractManager):
    def get_balance(self, address):
        """Token bakiyesi"""
        balance = self.read_function('balanceOf', address)
        return balance / (10 ** self.get_decimals()) if balance else 0
    
    def get_total_supply(self):
        """Toplam arz"""
        return self.read_function('totalSupply')
    
    def get_decimals(self):
        """Token ondalÄ±k sayÄ±sÄ±"""
        return self.read_function('decimals')
    
    def transfer_tokens(self, private_key, to_address, amount):
        """Token transfer et"""
        decimals = self.get_decimals()
        amount_with_decimals = int(amount * (10 ** decimals))
        
        return self.write_function(
            'transfer', 
            private_key, 
            to_address, 
            amount_with_decimals
        )</code></pre>
                    </div>
                </section>

                <section id="defi-uygulamalari">
                    <h2>ğŸ’° 5. DeFi UygulamalarÄ±</h2>
                    
                    <h3>Uniswap ile Token Swap</h3>
                    <div class="code-example">
                        <pre><code>import json
from web3 import Web3

class UniswapV3Manager:
    def __init__(self, w3):
        self.w3 = w3
        self.router_address = "0xE592427A0AEce92De3Edee1F18E0157C05861564"
        self.router_abi = [
            # Uniswap V3 Router ABI (kÄ±saltÄ±lmÄ±ÅŸ)
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenIn", "type": "address"},
                    {"internalType": "address", "name": "tokenOut", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "address", "name": "recipient", "type": "address"},
                    {"internalType": "uint256", "name": "deadline", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountOutMinimum", "type": "uint256"},
                    {"internalType": "uint160", "name": "sqrtPriceLimitX96", "type": "uint160"}
                ],
                "name": "exactInputSingle",
                "outputs": [{"internalType": "uint256", "name": "amountOut", "type": "uint256"}],
                "stateMutability": "payable",
                "type": "function"
            }
        ]
        self.router = w3.eth.contract(address=self.router_address, abi=self.router_abi)
    
    def get_token_price(self, token_address):
        """Token fiyatÄ±nÄ± USD cinsinden getir (CoinGecko API)"""
        import requests
        
        try:
            url = f"https://api.coingecko.com/api/v3/simple/token_price/ethereum"
            params = {
                'contract_addresses': token_address,
                'vs_currencies': 'usd'
            }
            response = requests.get(url, params=params)
            data = response.json()
            
            return data.get(token_address.lower(), {}).get('usd', 0)
        except Exception as e:
            print(f"Fiyat alma hatasÄ±: {e}")
            return 0
    
    def calculate_slippage(self, amount_in, amount_out_min, slippage_tolerance=0.5):
        """Slippage hesapla"""
        expected_amount = amount_in * 0.997  # %0.3 fee varsayÄ±mÄ±
        actual_slippage = ((expected_amount - amount_out_min) / expected_amount) * 100
        
        return {
            'expected_amount': expected_amount,
            'minimum_received': amount_out_min,
            'slippage_percent': actual_slippage,
            'within_tolerance': actual_slippage <= slippage_tolerance
        }
    
    def swap_tokens(self, private_key, token_in, token_out, amount_in, slippage=0.5):
        """Token swap iÅŸlemi"""
        try:
            account = Account.from_key(private_key)
            
            # Deadline (10 dakika sonra)
            deadline = int(time.time()) + 600
            
            # Minimum Ã§Ä±kÄ±ÅŸ miktarÄ± (slippage dahil)
            amount_out_min = int(amount_in * (1 - slippage/100) * 0.997)
            
            # Swap parametreleri
            params = {
                'tokenIn': token_in,
                'tokenOut': token_out,
                'fee': 3000,  # 0.3% fee pool
                'recipient': account.address,
                'deadline': deadline,
                'amountIn': amount_in,
                'amountOutMinimum': amount_out_min,
                'sqrtPriceLimitX96': 0
            }
            
            # Ä°ÅŸlem oluÅŸtur
            transaction = self.router.functions.exactInputSingle(params).build_transaction({
                'from': account.address,
                'gas': 300000,
                'gasPrice': self.w3.to_wei(30, 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(account.address),
                'value': amount_in if token_in == "0x0000000000000000000000000000000000000000" else 0
            })
            
            # Ä°mzala ve gÃ¶nder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            return tx_hash.hex()
            
        except Exception as e:
            print(f"Swap hatasÄ±: {e}")
            return None</code></pre>
                    </div>
                    
                    <h3>Yield Farming Bot</h3>
                    <div class="code-example">
                        <pre><code>import asyncio
import time
from datetime import datetime

class YieldFarmingBot:
    def __init__(self, w3, private_key):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        self.farming_pools = []
        self.min_apy = 15.0  # Minimum %15 APY
        
    def add_farming_pool(self, pool_address, token_pair, current_apy):
        """Farming pool ekle"""
        pool_info = {
            'address': pool_address,
            'token_pair': token_pair,
            'current_apy': current_apy,
            'last_check': time.time(),
            'is_farming': False
        }
        self.farming_pools.append(pool_info)
    
    async def monitor_pools(self):
        """Pool'larÄ± sÃ¼rekli izle"""
        while True:
            try:
                for pool in self.farming_pools:
                    current_apy = await self.get_pool_apy(pool['address'])
                    pool['current_apy'] = current_apy
                    
                    # APY yeterince yÃ¼ksekse farm et
                    if current_apy >= self.min_apy and not pool['is_farming']:
                        await self.start_farming(pool)
                    
                    # APY dÃ¼ÅŸtÃ¼yse Ã§Ä±k
                    elif current_apy < self.min_apy and pool['is_farming']:
                        await self.stop_farming(pool)
                    
                    pool['last_check'] = time.time()
                
                # 5 dakika bekle
                await asyncio.sleep(300)
                
            except Exception as e:
                print(f"Monitoring hatasÄ±: {e}")
                await asyncio.sleep(60)
    
    async def get_pool_apy(self, pool_address):
        """Pool APY hesapla"""
        # Bu fonksiyon gerÃ§ek pool verilerini analiz eder
        # Ã–rnek basit hesaplama
        try:
            # Pool contract'Ä±ndan veri Ã§ek
            # GerÃ§ek implementasyonda pool-specific hesaplamalar yapÄ±lÄ±r
            base_apy = 12.5
            volatility_bonus = 2.5
            return base_apy + volatility_bonus
        except:
            return 0
    
    async def start_farming(self, pool):
        """Farming baÅŸlat"""
        try:
            print(f"ğŸš€ Farming baÅŸlatÄ±lÄ±yor: {pool['token_pair']} (APY: {pool['current_apy']:.2f}%)")
            
            # Liquidity provide et
            # Bu Ã¶rnekte basitleÅŸtirilmiÅŸ
            pool['is_farming'] = True
            
            # Log kaydet
            with open('farming_log.txt', 'a') as f:
                f.write(f"{datetime.now()}: Started farming {pool['token_pair']} at {pool['current_apy']:.2f}% APY\n")
                
        except Exception as e:
            print(f"Farming baÅŸlatma hatasÄ±: {e}")
    
    async def stop_farming(self, pool):
        """Farming durdur"""
        try:
            print(f"ğŸ›‘ Farming durduruluyor: {pool['token_pair']} (APY dÃ¼ÅŸtÃ¼: {pool['current_apy']:.2f}%)")
            
            # Liquidity withdraw et
            pool['is_farming'] = False
            
            # KazancÄ± hesapla ve log'la
            with open('farming_log.txt', 'a') as f:
                f.write(f"{datetime.now()}: Stopped farming {pool['token_pair']} at {pool['current_apy']:.2f}% APY\n")
                
        except Exception as e:
            print(f"Farming durdurma hatasÄ±: {e}")

# KullanÄ±m
async def main():
    bot = YieldFarmingBot(w3, "YOUR_PRIVATE_KEY")
    
    # Pool'larÄ± ekle
    bot.add_farming_pool("0x...", "ETH/USDC", 18.5)
    bot.add_farming_pool("0x...", "ETH/DAI", 16.2)
    
    # Monitoring baÅŸlat
    await bot.monitor_pools()

# asyncio.run(main())</code></pre>
                    </div>
                </section>

                <section id="nft-projeleri">
                    <h2>ğŸ¨ 6. NFT Projeleri</h2>
                    
                    <h3>NFT Minting Bot</h3>
                    <div class="code-example">
                        <pre><code>import requests
import json
from PIL import Image
import hashlib

class NFTMintingBot:
    def __init__(self, w3, private_key, contract_address):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        self.contract_address = contract_address
        
        # ERC-721 ABI (basitleÅŸtirilmiÅŸ)
        self.nft_abi = [
            {
                "inputs": [
                    {"name": "to", "type": "address"},
                    {"name": "tokenURI", "type": "string"}
                ],
                "name": "mint",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ]
        
        self.contract = w3.eth.contract(address=contract_address, abi=self.nft_abi)
    
    def upload_to_ipfs(self, file_path, metadata):
        """DosyayÄ± IPFS'e yÃ¼kle"""
        try:
            # Pinata API kullanarak IPFS'e yÃ¼kleme
            pinata_api_key = "YOUR_PINATA_API_KEY"
            pinata_secret_key = "YOUR_PINATA_SECRET_KEY"
            
            # GÃ¶rsel yÃ¼kle
            with open(file_path, 'rb') as file:
                files = {'file': file}
                headers = {
                    'pinata_api_key': pinata_api_key,
                    'pinata_secret_api_key': pinata_secret_key
                }
                
                response = requests.post(
                    'https://api.pinata.cloud/pinning/pinFileToIPFS',
                    files=files,
                    headers=headers
                )
                
                if response.status_code == 200:
                    image_hash = response.json()['IpfsHash']
                    
                    # Metadata'yÄ± hazÄ±rla
                    nft_metadata = {
                        "name": metadata['name'],
                        "description": metadata['description'],
                        "image": f"ipfs://{image_hash}",
                        "attributes": metadata.get('attributes', [])
                    }
                    
                    # Metadata'yÄ± IPFS'e yÃ¼kle
                    metadata_response = requests.post(
                        'https://api.pinata.cloud/pinning/pinJSONToIPFS',
                        json=nft_metadata,
                        headers=headers
                    )
                    
                    if metadata_response.status_code == 200:
                        metadata_hash = metadata_response.json()['IpfsHash']
                        return f"ipfs://{metadata_hash}"
                
        except Exception as e:
            print(f"IPFS yÃ¼kleme hatasÄ±: {e}")
            return None
    
    def generate_art(self, traits):
        """Programmatik NFT art oluÅŸtur"""
        try:
            from PIL import Image, ImageDraw
            import random
            
            # 1000x1000 canvas
            img = Image.new('RGB', (1000, 1000), color='white')
            draw = ImageDraw.Draw(img)
            
            # Arka plan
            bg_color = random.choice(['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'])
            draw.rectangle([0, 0, 1000, 1000], fill=bg_color)
            
            # Åekiller ekle
            for _ in range(random.randint(3, 8)):
                x = random.randint(0, 800)
                y = random.randint(0, 800)
                size = random.randint(50, 200)
                color = random.choice(['#FFFFFF', '#000000', '#FF4757', '#2ED573'])
                
                if random.choice([True, False]):
                    # Daire
                    draw.ellipse([x, y, x+size, y+size], fill=color)
                else:
                    # Kare
                    draw.rectangle([x, y, x+size, y+size], fill=color)
            
            # Unique hash oluÅŸtur
            img_hash = hashlib.md5(str(traits).encode()).hexdigest()
            filename = f"generated_nft_{img_hash}.png"
            img.save(filename)
            
            return filename
            
        except Exception as e:
            print(f"Art oluÅŸturma hatasÄ±: {e}")
            return None
    
    def mint_nft(self, recipient, metadata):
        """NFT mint et"""
        try:
            # Art oluÅŸtur
            traits = {
                'background': metadata.get('background', 'blue'),
                'shape_count': metadata.get('shape_count', 5),
                'color_scheme': metadata.get('color_scheme', 'vibrant')
            }
            
            art_file = self.generate_art(traits)
            if not art_file:
                return None
            
            # IPFS'e yÃ¼kle
            token_uri = self.upload_to_ipfs(art_file, metadata)
            if not token_uri:
                return None
            
            # Mint iÅŸlemi
            transaction = self.contract.functions.mint(
                recipient, 
                token_uri
            ).build_transaction({
                'from': self.account.address,
                'gas': 200000,
                'gasPrice': self.w3.to_wei(20, 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            # Ä°mzala ve gÃ¶nder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, self.private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            print(f"âœ… NFT mint edildi! TX: {tx_hash.hex()}")
            print(f"ğŸ“ Metadata URI: {token_uri}")
            
            return {
                'tx_hash': tx_hash.hex(),
                'token_uri': token_uri,
                'art_file': art_file
            }
            
        except Exception as e:
            print(f"Mint hatasÄ±: {e}")
            return None
    
    def batch_mint(self, recipients, base_metadata, count=10):
        """Toplu NFT mint et"""
        results = []
        
        for i in range(count):
            recipient = recipients[i % len(recipients)]
            
            # Her NFT iÃ§in unique metadata
            metadata = base_metadata.copy()
            metadata['name'] = f"{metadata['name']} #{i+1}"
            metadata['attributes'].append({
                'trait_type': 'Generation',
                'value': f'Gen {i+1}'
            })
            
            result = self.mint_nft(recipient, metadata)
            if result:
                results.append(result)
                
            # Rate limiting
            time.sleep(2)
        
        return results

# KullanÄ±m
bot = NFTMintingBot(w3, "YOUR_PRIVATE_KEY", "NFT_CONTRACT_ADDRESS")

metadata = {
    'name': 'Generated Art Collection',
    'description': 'Algorithmically generated unique digital art',
    'attributes': [
        {'trait_type': 'Type', 'value': 'Generative'},
        {'trait_type': 'Rarity', 'value': 'Common'}
    ]
}

# Tek NFT mint et
result = bot.mint_nft("0x...", metadata)</code></pre>
                    </div>
                    
                    <h3>NFT Rarity Analyzer</h3>
                    <div class="code-example">
                        <pre><code>import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter

class NFTRarityAnalyzer:
    def __init__(self, collection_address):
        self.collection_address = collection_address
        self.nft_data = []
        self.trait_rarity = {}
    
    def fetch_collection_data(self):
        """OpenSea API'sinden koleksiyon verilerini Ã§ek"""
        try:
            import requests
            
            url = f"https://api.opensea.io/api/v1/assets"
            params = {
                'asset_contract_address': self.collection_address,
                'order_direction': 'desc',
                'offset': 0,
                'limit': 200
            }
            
            all_nfts = []
            offset = 0
            
            while len(all_nfts) < 1000:  # Max 1000 NFT analiz et
                params['offset'] = offset
                response = requests.get(url, params=params)
                
                if response.status_code == 200:
                    data = response.json()
                    assets = data.get('assets', [])
                    
                    if not assets:
                        break
                    
                    all_nfts.extend(assets)
                    offset += 200
                else:
                    break
            
            self.nft_data = all_nfts
            return len(all_nfts)
            
        except Exception as e:
            print(f"Veri Ã§ekme hatasÄ±: {e}")
            return 0
    
    def analyze_traits(self):
        """Trait rarity analizi yap"""
        trait_counts = {}
        total_nfts = len(self.nft_data)
        
        for nft in self.nft_data:
            traits = nft.get('traits', [])
            
            for trait in traits:
                trait_type = trait.get('trait_type')
                trait_value = trait.get('value')
                
                if trait_type and trait_value:
                    key = f"{trait_type}:{trait_value}"
                    trait_counts[key] = trait_counts.get(key, 0) + 1
        
        # Rarity skorlarÄ±nÄ± hesapla
        self.trait_rarity = {}
        for trait, count in trait_counts.items():
            rarity_score = (total_nfts - count) / total_nfts * 100
            self.trait_rarity[trait] = {
                'count': count,
                'rarity_score': rarity_score,
                'percentage': (count / total_nfts) * 100
            }
        
        return self.trait_rarity
    
    def calculate_nft_rarity(self, token_id):
        """Belirli bir NFT'nin rarity skorunu hesapla"""
        nft = next((n for n in self.nft_data if n.get('token_id') == str(token_id)), None)
        
        if not nft:
            return None
        
        total_rarity_score = 0
        trait_details = []
        
        for trait in nft.get('traits', []):
            trait_type = trait.get('trait_type')
            trait_value = trait.get('value')
            key = f"{trait_type}:{trait_value}"
            
            if key in self.trait_rarity:
                rarity_info = self.trait_rarity[key]
                total_rarity_score += rarity_info['rarity_score']
                
                trait_details.append({
                    'trait_type': trait_type,
                    'value': trait_value,
                    'rarity_score': rarity_info['rarity_score'],
                    'percentage': rarity_info['percentage']
                })
        
        return {
            'token_id': token_id,
            'total_rarity_score': total_rarity_score,
            'trait_count': len(trait_details),
            'traits': trait_details,
            'rank': self.get_rarity_rank(total_rarity_score)
        }
    
    def get_rarity_rank(self, rarity_score):
        """Rarity skoru'na gÃ¶re rank belirle"""
        all_scores = []
        
        for nft in self.nft_data:
            nft_score = 0
            for trait in nft.get('traits', []):
                trait_type = trait.get('trait_type')
                trait_value = trait.get('value')
                key = f"{trait_type}:{trait_value}"
                
                if key in self.trait_rarity:
                    nft_score += self.trait_rarity[key]['rarity_score']
            
            all_scores.append(nft_score)
        
        all_scores.sort(reverse=True)
        
        try:
            rank = all_scores.index(rarity_score) + 1
            return rank
        except ValueError:
            return len(all_scores) + 1
    
    def generate_rarity_report(self):
        """Rarity raporunu oluÅŸtur"""
        if not self.trait_rarity:
            self.analyze_traits()
        
        # En nadir trait'leri bul
        rarest_traits = sorted(
            self.trait_rarity.items(), 
            key=lambda x: x[1]['rarity_score'], 
            reverse=True
        )[:10]
        
        # Rapor oluÅŸtur
        report = {
            'collection_address': self.collection_address,
            'total_nfts': len(self.nft_data),
            'total_traits': len(self.trait_rarity),
            'rarest_traits': rarest_traits,
            'analysis_date': pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        return report
    
    def plot_rarity_distribution(self):
        """Rarity daÄŸÄ±lÄ±mÄ±nÄ± gÃ¶rselleÅŸtir"""
        scores = [info['rarity_score'] for info in self.trait_rarity.values()]
        
        plt.figure(figsize=(12, 6))
        
        plt.subplot(1, 2, 1)
        plt.hist(scores, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
        plt.title('Trait Rarity Score Distribution')
        plt.xlabel('Rarity Score')
        plt.ylabel('Frequency')
        
        plt.subplot(1, 2, 2)
        plt.boxplot(scores)
        plt.title('Rarity Score Box Plot')
        plt.ylabel('Rarity Score')
        
        plt.tight_layout()
        plt.savefig('rarity_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()

# KullanÄ±m
analyzer = NFTRarityAnalyzer("0x...")  # Collection address
nft_count = analyzer.fetch_collection_data()
print(f"Analiz edilen NFT sayÄ±sÄ±: {nft_count}")

analyzer.analyze_traits()
rarity_info = analyzer.calculate_nft_rarity("1234")
print(f"NFT #1234 rarity bilgisi: {rarity_info}")

report = analyzer.generate_rarity_report()
analyzer.plot_rarity_distribution()</code></pre>
                    </div>
                </section>

                <section id="trading-botlari">
                    <h2>ğŸ¤– 7. Trading ve Arbitraj BotlarÄ±</h2>
                    
                    <h3>Multi-DEX Arbitraj Botu</h3>
                    <div class="code-example">
                        <pre><code>import asyncio
import aiohttp
from decimal import Decimal
import time

class ArbitrageBot:
    def __init__(self, w3, private_key):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        
        # DEX'ler
        self.exchanges = {
            'uniswap_v2': {
                'router': '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
                'fee': 0.3
            },
            'sushiswap': {
                'router': '0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F',
                'fee': 0.3
            },
            'uniswap_v3': {
                'router': '0xE592427A0AEce92De3Edee1F18E0157C05861564',
                'fee': 0.3
            }
        }
        
        # Ä°zlenecek token Ã§iftleri
        self.token_pairs = [
            ('WETH', 'USDC'),
            ('WETH', 'DAI'),
            ('USDC', 'DAI'),
            ('WETH', 'USDT')
        ]
        
        self.min_profit_threshold = 50  # Minimum $50 kar
        self.max_slippage = 0.5  # %0.5 maksimum slippage
    
    async def get_token_price(self, session, exchange, token_in, token_out, amount_in):
        """Belirli bir DEX'teki token fiyatÄ±nÄ± al"""
        try:
            if exchange == 'uniswap_v2':
                return await self.get_uniswap_v2_price(session, token_in, token_out, amount_in)
            elif exchange == 'sushiswap':
                return await self.get_sushiswap_price(session, token_in, token_out, amount_in)
            elif exchange == 'uniswap_v3':
                return await self.get_uniswap_v3_price(session, token_in, token_out, amount_in)
            
        except Exception as e:
            print(f"Fiyat alma hatasÄ± ({exchange}): {e}")
            return None
    
    async def get_uniswap_v2_price(self, session, token_in, token_out, amount_in):
        """Uniswap V2 fiyatÄ±nÄ± al"""
        try:
            # Simplified - gerÃ§ek implementasyonda pair contract'Ä±nÄ± Ã§aÄŸÄ±rÄ±r
            url = f"https://api.uniswap.org/v2/quote"
            params = {
                'tokenIn': token_in,
                'tokenOut': token_out,
                'amountIn': amount_in
            }
            
            async with session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    return {
                        'exchange': 'uniswap_v2',
                        'amount_out': float(data.get('amountOut', 0)),
                        'gas_estimate': 150000,
                        'fee': self.exchanges['uniswap_v2']['fee']
                    }
        except:
            pass
        
        return None
    
    async def find_arbitrage_opportunities(self):
        """Arbitraj fÄ±rsatlarÄ±nÄ± bul"""
        opportunities = []
        
        async with aiohttp.ClientSession() as session:
            for token_pair in self.token_pairs:
                token_in, token_out = token_pair
                amount_in = 1000  # $1000 test miktarÄ±
                
                # TÃ¼m DEX'lerdeki fiyatlarÄ± al
                prices = {}
                for exchange in self.exchanges.keys():
                    price = await self.get_token_price(session, exchange, token_in, token_out, amount_in)
                    if price:
                        prices[exchange] = price
                
                # Arbitraj fÄ±rsatÄ± var mÄ± kontrol et
                if len(prices) >= 2:
                    # En dÃ¼ÅŸÃ¼k ve en yÃ¼ksek fiyatÄ± bul
                    buy_exchange = min(prices.keys(), key=lambda x: prices[x]['amount_out'])
                    sell_exchange = max(prices.keys(), key=lambda x: prices[x]['amount_out'])
                    
                    buy_price = prices[buy_exchange]['amount_out']
                    sell_price = prices[sell_exchange]['amount_out']
                    
                    # Profit hesapla
                    gross_profit = sell_price - buy_price
                    
                    # Gas maliyetlerini Ã§Ä±kar
                    total_gas = prices[buy_exchange]['gas_estimate'] + prices[sell_exchange]['gas_estimate']
                    gas_cost = total_gas * self.w3.to_wei(30, 'gwei') / 10**18 * 2000  # ETH fiyatÄ± $2000 varsayÄ±mÄ±
                    
                    # Swap fee'lerini Ã§Ä±kar
                    total_fees = (prices[buy_exchange]['fee'] + prices[sell_exchange]['fee']) / 100 * amount_in
                    
                    net_profit = gross_profit - gas_cost - total_fees
                    
                    if net_profit > self.min_profit_threshold:
                        opportunity = {
                            'token_pair': token_pair,
                            'buy_exchange': buy_exchange,
                            'sell_exchange': sell_exchange,
                            'buy_price': buy_price,
                            'sell_price': sell_price,
                            'gross_profit': gross_profit,
                            'gas_cost': gas_cost,
                            'fees': total_fees,
                            'net_profit': net_profit,
                            'profit_percentage': (net_profit / amount_in) * 100,
                            'timestamp': time.time()
                        }
                        opportunities.append(opportunity)
        
        return opportunities
    
    async def execute_arbitrage(self, opportunity):
        """Arbitraj iÅŸlemini gerÃ§ekleÅŸtir"""
        try:
            print(f"ğŸš€ Arbitraj iÅŸlemi baÅŸlatÄ±lÄ±yor...")
            print(f"Token Pair: {opportunity['token_pair']}")
            print(f"Buy: {opportunity['buy_exchange']} - Sell: {opportunity['sell_exchange']}")
            print(f"Beklenen kar: ${opportunity['net_profit']:.2f}")
            
            # 1. Ä°lk DEX'te satÄ±n al
            buy_tx = await self.execute_swap(
                opportunity['buy_exchange'],
                opportunity['token_pair'][0],
                opportunity['token_pair'][1],
                1000  # $1000
            )
            
            if not buy_tx:
                print("âŒ SatÄ±n alma iÅŸlemi baÅŸarÄ±sÄ±z")
                return False
            
            # Transaction confirm olmasÄ±nÄ± bekle
            receipt = self.w3.eth.wait_for_transaction_receipt(buy_tx)
            if receipt.status != 1:
                print("âŒ SatÄ±n alma transaction'Ä± baÅŸarÄ±sÄ±z")
                return False
            
            # 2. Ä°kinci DEX'te sat
            sell_tx = await self.execute_swap(
                opportunity['sell_exchange'],
                opportunity['token_pair'][1],
                opportunity['token_pair'][0],
                opportunity['buy_price']
            )
            
            if not sell_tx:
                print("âŒ SatÄ±ÅŸ iÅŸlemi baÅŸarÄ±sÄ±z")
                return False
            
            # Transaction confirm olmasÄ±nÄ± bekle
            receipt = self.w3.eth.wait_for_transaction_receipt(sell_tx)
            if receipt.status == 1:
                print("âœ… Arbitraj iÅŸlemi baÅŸarÄ±yla tamamlandÄ±!")
                
                # SonuÃ§larÄ± logla
                with open('arbitrage_log.txt', 'a') as f:
                    f.write(f"{time.ctime()}: Successful arbitrage - Profit: ${opportunity['net_profit']:.2f}\n")
                
                return True
            else:
                print("âŒ SatÄ±ÅŸ transaction'Ä± baÅŸarÄ±sÄ±z")
                return False
                
        except Exception as e:
            print(f"Arbitraj hatasÄ±: {e}")
            return False
    
    async def execute_swap(self, exchange, token_in, token_out, amount):
        """Swap iÅŸlemini gerÃ§ekleÅŸtir"""
        try:
            # Bu fonksiyon gerÃ§ek DEX router'larÄ±nÄ± Ã§aÄŸÄ±rÄ±r
            # Her DEX iÃ§in farklÄ± implementation gerekir
            
            router_address = self.exchanges[exchange]['router']
            
            # Simplified swap logic
            # GerÃ§ek implementasyonda ERC-20 approve + swap yapÄ±lÄ±r
            
            return "0x..." + "mock_tx_hash"  # Mock transaction hash
            
        except Exception as e:
            print(f"Swap hatasÄ±: {e}")
            return None
    
    async def run_bot(self):
        """Bot'u sÃ¼rekli Ã§alÄ±ÅŸtÄ±r"""
        print("ğŸ¤– Arbitraj botu baÅŸlatÄ±ldÄ±...")
        
        while True:
            try:
                # Arbitraj fÄ±rsatlarÄ±nÄ± bul
                opportunities = await self.find_arbitrage_opportunities()
                
                if opportunities:
                    print(f"ğŸ’° {len(opportunities)} arbitraj fÄ±rsatÄ± bulundu!")
                    
                    # En karlÄ± fÄ±rsatÄ± seÃ§
                    best_opportunity = max(opportunities, key=lambda x: x['net_profit'])
                    
                    print(f"En iyi fÄ±rsat: ${best_opportunity['net_profit']:.2f} kar")
                    
                    # Arbitraj iÅŸlemini gerÃ§ekleÅŸtir
                    if best_opportunity['net_profit'] > self.min_profit_threshold:
                        success = await self.execute_arbitrage(best_opportunity)
                        
                        if success:
                            # BaÅŸarÄ±lÄ± iÅŸlemden sonra biraz bekle
                            await asyncio.sleep(30)
                else:
                    print("ğŸ“Š Arbitraj fÄ±rsatÄ± bulunamadÄ±")
                
                # 10 saniye bekle
                await asyncio.sleep(10)
                
            except Exception as e:
                print(f"Bot hatasÄ±: {e}")
                await asyncio.sleep(60)

# KullanÄ±m
async def main():
    bot = ArbitrageBot(w3, "YOUR_PRIVATE_KEY")
    await bot.run_bot()

# asyncio.run(main())</code></pre>
                    </div>
                </section>

                <section id="veri-analizi">
                    <h2>ğŸ“Š 8. Blockchain Veri Analizi</h2>
                    
                    <h3>On-Chain Veri Analizi</h3>
                    <div class="code-example">
                        <pre><code>import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import numpy as np

class BlockchainAnalyzer:
    def __init__(self, w3):
        self.w3 = w3
        self.df_transactions = pd.DataFrame()
        self.df_blocks = pd.DataFrame()
    
    def fetch_recent_blocks(self, block_count=1000):
        """Son N bloÄŸu Ã§ek ve analiz et"""
        try:
            latest_block = self.w3.eth.block_number
            blocks_data = []
            
            print(f"ğŸ“¥ Son {block_count} blok Ã§ekiliyor...")
            
            for i in range(block_count):
                block_number = latest_block - i
                block = self.w3.eth.get_block(block_number, full_transactions=True)
                
                block_data = {
                    'block_number': block.number,
                    'timestamp': datetime.fromtimestamp(block.timestamp),
                    'transaction_count': len(block.transactions),
                    'gas_used': block.gasUsed,
                    'gas_limit': block.gasLimit,
                    'gas_utilization': (block.gasUsed / block.gasLimit) * 100,
                    'base_fee': block.get('baseFeePerGas', 0),
                    'size': block.size,
                    'difficulty': block.difficulty
                }
                
                blocks_data.append(block_data)
                
                if i % 100 == 0:
                    print(f"Ä°ÅŸlenen blok sayÄ±sÄ±: {i+1}")
            
            self.df_blocks = pd.DataFrame(blocks_data)
            return len(blocks_data)
            
        except Exception as e:
            print(f"Blok Ã§ekme hatasÄ±: {e}")
            return 0
    
    def analyze_gas_trends(self):
        """Gas trendlerini analiz et"""
        if self.df_blocks.empty:
            return None
        
        # Gas fiyat trendleri
        self.df_blocks['hour'] = self.df_blocks['timestamp'].dt.hour
        hourly_gas = self.df_blocks.groupby('hour').agg({
            'base_fee': 'mean',
            'gas_utilization': 'mean',
            'transaction_count': 'mean'
        }).round(2)
        
        # GÃ¶rselleÅŸtirme
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # Gas fiyat trendi
        axes[0, 0].plot(self.df_blocks['timestamp'], self.df_blocks['base_fee'])
        axes[0, 0].set_title('Gas Base Fee Trendi')
        axes[0, 0].set_xlabel('Zaman')
        axes[0, 0].set_ylabel('Base Fee (Gwei)')
        
        # Gas kullanÄ±m oranÄ±
        axes[0, 1].plot(self.df_blocks['timestamp'], self.df_blocks['gas_utilization'])
        axes[0, 1].set_title('Gas KullanÄ±m OranÄ±')
        axes[0, 1].set_xlabel('Zaman')
        axes[0, 1].set_ylabel('KullanÄ±m OranÄ± (%)')
        
        # Saatlik gas fiyatlarÄ±
        axes[1, 0].bar(hourly_gas.index, hourly_gas['base_fee'])
        axes[1, 0].set_title('Saatlik Ortalama Gas FiyatlarÄ±')
        axes[1, 0].set_xlabel('Saat')
        axes[1, 0].set_ylabel('Base Fee (Gwei)')
        
        # Transaction sayÄ±sÄ± vs Gas fiyatÄ±
        axes[1, 1].scatter(self.df_blocks['transaction_count'], self.df_blocks['base_fee'], alpha=0.6)
        axes[1, 1].set_title('Transaction SayÄ±sÄ± vs Gas FiyatÄ±')
        axes[1, 1].set_xlabel('Transaction SayÄ±sÄ±')
        axes[1, 1].set_ylabel('Base Fee (Gwei)')
        
        plt.tight_layout()
        plt.savefig('gas_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return {
            'hourly_stats': hourly_gas,
            'peak_hours': hourly_gas['base_fee'].nlargest(3).index.tolist(),
            'low_hours': hourly_gas['base_fee'].nsmallest(3).index.tolist(),
            'avg_gas_price': self.df_blocks['base_fee'].mean(),
            'avg_utilization': self.df_blocks['gas_utilization'].mean()
        }
    
    def analyze_whale_movements(self, min_value_eth=100):
        """Whale hareketlerini analiz et"""
        try:
            whale_transactions = []
            
            # Son 100 bloktaki bÃ¼yÃ¼k transferleri bul
            for _, block_info in self.df_blocks.head(100).iterrows():
                block = self.w3.eth.get_block(block_info['block_number'], full_transactions=True)
                
                for tx in block.transactions:
                    if tx.value > 0:
                        value_eth = self.w3.from_wei(tx.value, 'ether')
                        
                        if value_eth >= min_value_eth:
                            whale_tx = {
                                'hash': tx.hash.hex(),
                                'from': tx['from'],
                                'to': tx.to,
                                'value_eth': float(value_eth),
                                'gas_price': tx.gasPrice,
                                'timestamp': block_info['timestamp'],
                                'block_number': block_info['block_number']
                            }
                            whale_transactions.append(whale_tx)
            
            if whale_transactions:
                df_whales = pd.DataFrame(whale_transactions)
                
                # Whale analizi
                whale_stats = {
                    'total_whale_txs': len(df_whales),
                    'total_value_moved': df_whales['value_eth'].sum(),
                    'avg_whale_tx_size': df_whales['value_eth'].mean(),
                    'largest_tx': df_whales.loc[df_whales['value_eth'].idxmax()],
                    'top_whale_addresses': df_whales.groupby('from')['value_eth'].sum().nlargest(5)
                }
                
                # Whale aktivite grafiÄŸi
                plt.figure(figsize=(12, 6))
                plt.scatter(df_whales['timestamp'], df_whales['value_eth'], 
                           alpha=0.7, s=50, c='red')
                plt.title(f'Whale Aktivitesi (>{min_value_eth} ETH)')
                plt.xlabel('Zaman')
                plt.ylabel('Transfer MiktarÄ± (ETH)')
                plt.yscale('log')
                plt.grid(True, alpha=0.3)
                plt.tight_layout()
                plt.savefig('whale_activity.png', dpi=300, bbox_inches='tight')
                plt.show()
                
                return whale_stats
            
        except Exception as e:
            print(f"Whale analizi hatasÄ±: {e}")
            return None
    
    def predict_gas_prices(self):
        """Gas fiyatlarÄ±nÄ± makine Ã¶ÄŸrenmesi ile tahmin et"""
        try:
            from sklearn.linear_model import LinearRegression
            from sklearn.ensemble import RandomForestRegressor
            from sklearn.metrics import mean_absolute_error, r2_score
            from sklearn.preprocessing import StandardScaler
            
            if len(self.df_blocks) < 100:
                print("Yeterli veri yok")
                return None
            
            # Feature engineering
            self.df_blocks['hour'] = self.df_blocks['timestamp'].dt.hour
            self.df_blocks['day_of_week'] = self.df_blocks['timestamp'].dt.dayofweek
            self.df_blocks['is_weekend'] = self.df_blocks['day_of_week'].isin([5, 6]).astype(int)
            
            # Features
            features = [
                'gas_utilization', 'transaction_count', 'hour', 
                'day_of_week', 'is_weekend', 'difficulty'
            ]
            
            # Veriyi hazÄ±rla
            X = self.df_blocks[features].fillna(0)
            y = self.df_blocks['base_fee']
            
            # Train/test split
            split_idx = int(len(X) * 0.8)
            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]
            
            # Model eÄŸitimi
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            # Random Forest modeli
            rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
            rf_model.fit(X_train_scaled, y_train)
            
            # Tahminler
            y_pred = rf_model.predict(X_test_scaled)
            
            # Model performansÄ±
            mae = mean_absolute_error(y_test, y_pred)
            r2 = r2_score(y_test, y_pred)
            
            # Feature importance
            feature_importance = pd.DataFrame({
                'feature': features,
                'importance': rf_model.feature_importances_
            }).sort_values('importance', ascending=False)
            
            # SonuÃ§larÄ± gÃ¶rselleÅŸtir
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))
            
            # Tahmin vs GerÃ§ek
            axes[0].scatter(y_test, y_pred, alpha=0.6)
            axes[0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
            axes[0].set_xlabel('GerÃ§ek Gas FiyatÄ±')
            axes[0].set_ylabel('Tahmin Edilen Gas FiyatÄ±')
            axes[0].set_title(f'Gas Fiyat Tahmini (RÂ²: {r2:.3f})')
            
            # Feature importance
            axes[1].barh(feature_importance['feature'], feature_importance['importance'])
            axes[1].set_xlabel('Ã–nem Skoru')
            axes[1].set_title('Feature Importance')
            
            plt.tight_layout()
            plt.savefig('gas_prediction.png', dpi=300, bbox_inches='tight')
            plt.show()
            
            # Gelecek saatler iÃ§in tahmin
            future_predictions = []
            current_hour = datetime.now().hour
            
            for hour_offset in range(1, 25):  # Sonraki 24 saat
                future_hour = (current_hour + hour_offset) % 24
                
                # Ortalama deÄŸerleri kullan
                avg_utilization = self.df_blocks['gas_utilization'].mean()
                avg_tx_count = self.df_blocks['transaction_count'].mean()
                avg_difficulty = self.df_blocks['difficulty'].mean()
                
                future_features = [
                    avg_utilization,
                    avg_tx_count,
                    future_hour,
                    datetime.now().weekday(),
                    1 if datetime.now().weekday() in [5, 6] else 0,
                    avg_difficulty
                ]
                
                future_scaled = scaler.transform([future_features])
                predicted_gas = rf_model.predict(future_scaled)[0]
                
                future_predictions.append({
                    'hour_offset': hour_offset,
                    'predicted_hour': future_hour,
                    'predicted_gas_price': predicted_gas
                })
            
            return {
                'model_performance': {'mae': mae, 'r2': r2},
                'feature_importance': feature_importance,
                'future_predictions': future_predictions,
                'best_hours_to_transact': sorted(future_predictions, key=lambda x: x['predicted_gas_price'])[:3]
            }
            
        except Exception as e:
            print(f"Tahmin hatasÄ±: {e}")
            return None

# KullanÄ±m
analyzer = BlockchainAnalyzer(w3)

# Veri toplama
block_count = analyzer.fetch_recent_blocks(500)
print(f"Toplanan blok sayÄ±sÄ±: {block_count}")

# Gas analizi
gas_analysis = analyzer.analyze_gas_trends()
print("Gas Analizi:", gas_analysis)

# Whale analizi
whale_analysis = analyzer.analyze_whale_movements(min_value_eth=50)
print("Whale Analizi:", whale_analysis)

# Gas fiyat tahmini
prediction_results = analyzer.predict_gas_prices()
print("Tahmin SonuÃ§larÄ±:", prediction_results)</code></pre>
                    </div>
                </section>

                <section id="guvenlik">
                    <h2>ğŸ”’ 9. GÃ¼venlik ve En Ä°yi Uygulamalar</h2>
                    
                    <h3>Private Key YÃ¶netimi</h3>
                    <div class="warning-box">
                        <h4>âš ï¸ Kritik GÃ¼venlik UyarÄ±larÄ±:</h4>
                        <ul>
                            <li>Private key'leri asla hardcode etmeyin</li>
                            <li>Environment variable'lar kullanÄ±n</li>
                            <li>Hardware wallet entegrasyonu tercih edin</li>
                            <li>Multi-signature cÃ¼zdan kullanÄ±n</li>
                            <li>Test network'te Ã¶nce deneyin</li>
                        </ul>
                    </div>
                    
                    <div class="code-example">
                        <pre><code>import os
import keyring
from cryptography.fernet import Fernet
import hashlib

class SecureWalletManager:
    def __init__(self):
        self.fernet = None
        self.setup_encryption()
    
    def setup_encryption(self):
        """Åifreleme anahtarÄ±nÄ± kurma"""
        # Master password'dan key tÃ¼ret
        master_password = os.getenv('MASTER_PASSWORD')
        if not master_password:
            raise ValueError("MASTER_PASSWORD environment variable gerekli")
        
        # Deterministic key oluÅŸtur
        key = hashlib.pbkdf2_hmac(
            'sha256',
            master_password.encode(),
            b'salt_12345',  # Production'da random salt kullan
            100000
        )
        
        # Base64 encode et (Fernet iÃ§in gerekli)
        key_b64 = base64.urlsafe_b64encode(key[:32])
        self.fernet = Fernet(key_b64)
    
    def store_private_key(self, account_name, private_key):
        """Private key'i gÃ¼venli ÅŸekilde sakla"""
        try:
            # Åifrele
            encrypted_key = self.fernet.encrypt(private_key.encode())
            
            # Sistem keyring'e kaydet
            keyring.set_password("blockchain_app", account_name, encrypted_key.decode())
            
            print(f"âœ… {account_name} hesabÄ± gÃ¼venli ÅŸekilde saklandÄ±")
            return True
            
        except Exception as e:
            print(f"Saklama hatasÄ±: {e}")
            return False
    
    def load_private_key(self, account_name):
        """Private key'i gÃ¼venli ÅŸekilde yÃ¼kle"""
        try:
            # Keyring'den al
            encrypted_key = keyring.get_password("blockchain_app", account_name)
            if not encrypted_key:
                raise ValueError("Hesap bulunamadÄ±")
            
            # Åifreyi Ã§Ã¶z
            decrypted_key = self.fernet.decrypt(encrypted_key.encode())
            
            return decrypted_key.decode()
            
        except Exception as e:
            print(f"YÃ¼kleme hatasÄ±: {e}")
            return None
    
    def create_secure_transaction(self, account_name, to_address, value, gas_limit=21000):
        """GÃ¼venli transaction oluÅŸtur"""
        try:
            private_key = self.load_private_key(account_name)
            if not private_key:
                return None
            
            account = Account.from_key(private_key)
            
            # Nonce kontrolÃ¼
            nonce = self.w3.eth.get_transaction_count(account.address, 'pending')
            
            # Gas fiyatÄ± optimizasyonu
            gas_price = self.get_optimal_gas_price()
            
            # Transaction oluÅŸtur
            transaction = {
                'to': to_address,
                'value': value,
                'gas': gas_limit,
                'gasPrice': gas_price,
                'nonce': nonce,
                'chainId': 1  # Mainnet
            }
            
            # Ä°mzala
            signed_txn = account.sign_transaction(transaction)
            
            return signed_txn
            
        except Exception as e:
            print(f"Transaction oluÅŸturma hatasÄ±: {e}")
            return None
    
    def get_optimal_gas_price(self):
        """Optimal gas fiyatÄ±nÄ± hesapla"""
        try:
            # Son 10 bloktaki gas fiyatlarÄ±nÄ± al
            latest_block = self.w3.eth.block_number
            gas_prices = []
            
            for i in range(10):
                block = self.w3.eth.get_block(latest_block - i, full_transactions=True)
                for tx in block.transactions[:5]:  # Her bloktan 5 transaction
                    if tx.gasPrice:
                        gas_prices.append(tx.gasPrice)
            
            if gas_prices:
                # Medyan gas fiyatÄ±nÄ± kullan
                gas_prices.sort()
                median_gas = gas_prices[len(gas_prices) // 2]
                
                # %10 premium ekle (hÄ±zlÄ± onay iÃ§in)
                optimal_gas = int(median_gas * 1.1)
                
                return optimal_gas
            else:
                # Fallback gas fiyatÄ±
                return self.w3.to_wei(20, 'gwei')
                
        except Exception as e:
            print(f"Gas fiyat hesaplama hatasÄ±: {e}")
            return self.w3.to_wei(20, 'gwei')

class ContractAuditor:
    """Smart contract gÃ¼venlik denetimi"""
    
    def __init__(self, w3):
        self.w3 = w3
        self.vulnerability_patterns = {
            'reentrancy': [
                'call.value',
                'send(',
                'transfer(',
                'call.gas'
            ],
            'integer_overflow': [
                'SafeMath',
                'unchecked',
                '**'
            ],
            'access_control': [
                'onlyOwner',
                'require(msg.sender',
                'modifier'
            ]
        }
    
    def audit_contract(self, contract_address):
        """Contract'Ä± gÃ¼venlik aÃ§Ä±sÄ±ndan denetle"""
        try:
            # Contract kodunu al (verified contract'lar iÃ§in)
            # Bu Ã¶rnekte basitleÅŸtirilmiÅŸ
            
            audit_results = {
                'contract_address': contract_address,
                'audit_date': datetime.now().isoformat(),
                'vulnerabilities': [],
                'recommendations': [],
                'risk_score': 0
            }
            
            # Transaction pattern analizi
            recent_txs = self.analyze_transaction_patterns(contract_address)
            
            # Gas kullanÄ±m analizi
            gas_analysis = self.analyze_gas_usage(contract_address)
            
            # Event analizi
            event_analysis = self.analyze_events(contract_address)
            
            # Risk skoru hesapla
            risk_score = self.calculate_risk_score(recent_txs, gas_analysis, event_analysis)
            
            audit_results['risk_score'] = risk_score
            audit_results['transaction_analysis'] = recent_txs
            audit_results['gas_analysis'] = gas_analysis
            audit_results['event_analysis'] = event_analysis
            
            if risk_score > 70:
                audit_results['recommendations'].append("âš ï¸ YÃ¼ksek risk - contract kullanÄ±mÄ±na dikkat edin")
            elif risk_score > 40:
                audit_results['recommendations'].append("âš¡ Orta risk - iÅŸlemlerinizi kÃ¼Ã§Ã¼k miktarlarla test edin")
            else:
                audit_results['recommendations'].append("âœ… DÃ¼ÅŸÃ¼k risk - normal kullanÄ±m iÃ§in gÃ¼venli gÃ¶rÃ¼nÃ¼yor")
            
            return audit_results
            
        except Exception as e:
            print(f"Audit hatasÄ±: {e}")
            return None
    
    def calculate_risk_score(self, tx_analysis, gas_analysis, event_analysis):
        """Risk skorunu hesapla (0-100)"""
        score = 0
        
        # Transaction pattern riski
        if tx_analysis.get('failed_tx_rate', 0) > 0.05:  # %5'ten fazla baÅŸarÄ±sÄ±z tx
            score += 30
        
        # Gas kullanÄ±m riski
        if gas_analysis.get('avg_gas_usage', 0) > 500000:  # YÃ¼ksek gas kullanÄ±mÄ±
            score += 20
        
        # Event pattern riski
        if event_analysis.get('unusual_events', 0) > 0:
            score += 25
        
        # Son aktivite riski
        if tx_analysis.get('last_activity_hours', 0) > 168:  # 1 haftadan fazla inaktif
            score += 15
        
        return min(score, 100)

# KullanÄ±m
secure_wallet = SecureWalletManager()

# Private key'i gÃ¼venli sakla
secure_wallet.store_private_key("my_account", "0x...")

# GÃ¼venli transaction oluÅŸtur
signed_tx = secure_wallet.create_secure_transaction(
    "my_account", 
    "0x...", 
    w3.to_wei(0.1, 'ether')
)

# Contract audit
auditor = ContractAuditor(w3)
audit_result = auditor.audit_contract("0x...")
print("Audit Sonucu:", audit_result)</code></pre>
                    </div>
                </section>

                <section id="gelecek-trendler">
                    <h2>ğŸš€ 10. 2025 Trendleri ve Gelecek</h2>
                    
                    <h3>GeliÅŸen Teknolojiler</h3>
                    <div class="trend-grid">
                        <div class="trend-item">
                            <h4>ğŸ”— Layer 2 Ã‡Ã¶zÃ¼mleri</h4>
                            <p>Polygon, Arbitrum, Optimism gibi Layer 2 aÄŸlarÄ± Ethereum'un Ã¶lÃ§eklenebilirlik sorunlarÄ±nÄ± Ã§Ã¶zerken, Python geliÅŸtiricileri iÃ§in yeni fÄ±rsatlar yaratÄ±yor.</p>
                            <ul>
                                <li>DÃ¼ÅŸÃ¼k gas maliyetleri</li>
                                <li>HÄ±zlÄ± transaction onaylarÄ±</li>
                                <li>Ethereum uyumluluÄŸu</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>ğŸŒ Cross-Chain Protokoller</h4>
                            <p>FarklÄ± blockchain'ler arasÄ± kÃ¶prÃ¼ protokolleri, multi-chain uygulamalar iÃ§in Python araÃ§larÄ±na ihtiyaÃ§ artÄ±rÄ±yor.</p>
                            <ul>
                                <li>Bridge protokolleri</li>
                                <li>Cross-chain DEX'ler</li>
                                <li>Multi-chain portfÃ¶y yÃ¶netimi</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>ğŸ¤– AI + Blockchain</h4>
                            <p>Yapay zeka ve blockchain'in birleÅŸimi, Python'un gÃ¼Ã§lÃ¼ AI kÃ¼tÃ¼phaneleri ile Ã¶nemli fÄ±rsatlar sunuyor.</p>
                            <ul>
                                <li>AI-powered trading botlarÄ±</li>
                                <li>Prediction marketler</li>
                                <li>Decentralized AI servisleri</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>ğŸ›ï¸ RWA Tokenization</h4>
                            <p>Real World Assets'lerin tokenleÅŸtirilmesi, Python ile veri entegrasyonu ve analizi gerektiriyor.</p>
                            <ul>
                                <li>Gayrimenkul tokenleÅŸtirilmesi</li>
                                <li>Commodity tokenlarÄ±</li>
                                <li>Carbon credit tokenlarÄ±</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3>Ã–ÄŸrenme Yol HaritasÄ± 2025</h3>
                    <div class="roadmap">
                        <div class="roadmap-step">
                            <h4>ğŸ¯ BaÅŸlangÄ±Ã§ (1-2 ay)</h4>
                            <ul>
                                <li>Python temellerini pekiÅŸtirin</li>
                                <li>Web3.py kÃ¼tÃ¼phanesini Ã¶ÄŸrenin</li>
                                <li>Testnet'te denemeler yapÄ±n</li>
                                <li>Basit wallet uygulamasÄ± geliÅŸtirin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>ğŸ“ˆ Orta Seviye (3-4 ay)</h4>
                            <ul>
                                <li>Smart contract etkileÅŸimlerini Ã¶ÄŸrenin</li>
                                <li>DeFi protokolleri ile Ã§alÄ±ÅŸÄ±n</li>
                                <li>Basic trading bot geliÅŸtirin</li>
                                <li>NFT projelerini keÅŸfedin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>ğŸš€ Ä°leri Seviye (5-6 ay)</h4>
                            <ul>
                                <li>Cross-chain uygulamalar geliÅŸtirin</li>
                                <li>Advanced arbitraj sistemleri</li>
                                <li>Yield farming optimizasyonu</li>
                                <li>MEV botlarÄ± geliÅŸtirin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>ğŸ’ Uzman Seviye (6+ ay)</h4>
                            <ul>
                                <li>Kendi DeFi protokolÃ¼nÃ¼zÃ¼ geliÅŸtirin</li>
                                <li>AI-powered blockchain uygulamalarÄ±</li>
                                <li>Institutional trading sistemleri</li>
                                <li>Blockchain consulting hizmetleri</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3>Tavsiye Edilen Kaynaklar</h3>
                    <div class="resources-grid">
                        <div class="resource-item">
                            <h4>ğŸ“š KÃ¼tÃ¼phaneler</h4>
                            <ul>
                                <li><strong>Web3.py:</strong> Ethereum etkileÅŸimi</li>
                                <li><strong>Brownie:</strong> Smart contract development</li>
                                <li><strong>eth-account:</strong> Account management</li>
                                <li><strong>pycoingecko:</strong> Fiyat verileri</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>ğŸ”§ AraÃ§lar</h4>
                            <ul>
                                <li><strong>Hardhat:</strong> Development framework</li>
                                <li><strong>Remix:</strong> Online IDE</li>
                                <li><strong>MetaMask:</strong> Browser wallet</li>
                                <li><strong>Etherscan:</strong> Blockchain explorer</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>ğŸŒ Platformlar</h4>
                            <ul>
                                <li><strong>OpenZeppelin:</strong> Secure contracts</li>
                                <li><strong>Uniswap:</strong> DEX protokolÃ¼</li>
                                <li><strong>Aave:</strong> Lending protokolÃ¼</li>
                                <li><strong>OpenSea:</strong> NFT marketplace</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>ğŸ“– EÄŸitim</h4>
                            <ul>
                                <li><strong>CryptoZombies:</strong> Game-based learning</li>
                                <li><strong>Consensys Academy:</strong> Professional courses</li>
                                <li><strong>Ethereum.org:</strong> Official documentation</li>
                                <li><strong>DeFi Pulse:</strong> Market insights</li>
                            </ul>
                        </div>
                    </div>
                </section>
            </div>

            <!-- Article Footer -->
            <footer class="article-footer">
                <div class="article-tags">
                    <h4>ğŸ·ï¸ Etiketler:</h4>
                    <span class="tag">#python</span>
                    <span class="tag">#blockchain</span>
                    <span class="tag">#web3</span>
                    <span class="tag">#defi</span>
                    <span class="tag">#nft</span>
                    <span class="tag">#ethereum</span>
                    <span class="tag">#smart-contracts</span>
                    <span class="tag">#crypto</span>
                </div>
                
                <div class="share-buttons">
                    <h4>ğŸ“¤ PaylaÅŸ:</h4>
                    <a href="#" class="share-btn twitter">Twitter</a>
                    <a href="#" class="share-btn linkedin">LinkedIn</a>
                    <a href="#" class="share-btn facebook">Facebook</a>
                    <a href="#" class="share-btn copy">Link Kopyala</a>
                </div>
                
                <div class="author-info">
                    <h4>âœï¸ Yazar HakkÄ±nda</h4>
                    <p>Bu makale Python ve blockchain teknolojileri konusunda deneyimli geliÅŸtiriciler tarafÄ±ndan hazÄ±rlanmÄ±ÅŸtÄ±r. En gÃ¼ncel bilgiler ve pratik Ã¶rneklerle blockchain dÃ¼nyasÄ±na giriÅŸ yapmanÄ±zÄ± kolaylaÅŸtÄ±rmayÄ± hedefliyoruz.</p>
                </div>
            </footer>
        </article>

        <!-- Related Articles -->
        <section class="related-articles">
            <h3>ğŸ“– Ä°lgili Makaleler</h3>
            <div class="related-grid">
                <article class="related-card">
                    <h4><a href="python-ile-para-kazanma-15-yontem-2025.html">ğŸ’° Python ile Para Kazanma: 15 FarklÄ± YÃ¶ntem</a></h4>
                    <p>Python bilginizi paraya Ã§evirmenin kanÄ±tlanmÄ±ÅŸ yÃ¶ntemleri</p>
                </article>
                <article class="related-card">
                    <h4><a href="chatgpt-ile-python-kodlama-ai-destekli-programlama.html">ğŸ¤– ChatGPT ile Python Kodlama</a></h4>
                    <p>AI destekli programlama teknikleri ve ipuÃ§larÄ±</p>
                </article>
                <article class="related-card">
                    <h4><a href="../web-dev/web3-ve-blockchain-integration.html">ğŸŒ Web3 ve Blockchain Entegrasyonu</a></h4>
                    <p>Modern web uygulamalarÄ±nda blockchain kullanÄ±mÄ±</p>
                </article>
            </div>
        </section>
    </main>

    <!-- Sidebar Ad -->
    <aside class="sidebar">
        <div class="ad-zone-sidebar">
            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="2077956392" data-ad-format="auto" data-full-width-responsive="true"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
    </aside>

    <!-- Footer Ad -->
    <div class="ad-zone-footer">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="9486093631" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <!-- JavaScript -->
    <script>
        // Smooth scrolling for table of contents
        document.querySelectorAll('.table-of-contents a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Copy code functionality
        document.querySelectorAll('.code-example').forEach(codeBlock => {
            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'ğŸ“‹ Kopyala';
            copyBtn.className = 'copy-btn';
            
            copyBtn.addEventListener('click', () => {
                const code = codeBlock.querySelector('code').textContent;
                navigator.clipboard.writeText(code).then(() => {
                    copyBtn.textContent = 'âœ… KopyalandÄ±!';
                    setTimeout(() => {
                        copyBtn.textContent = 'ğŸ“‹ Kopyala';
                    }, 2000);
                });
            });
            
            codeBlock.appendChild(copyBtn);
        });

        // Share functionality
        document.querySelectorAll('.share-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const url = window.location.href;
                const title = document.title;
                
                if (this.classList.contains('twitter')) {
                    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(title)}&url=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('linkedin')) {
                    window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('facebook')) {
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('copy')) {
                    navigator.clipboard.writeText(url).then(() => {
                        this.textContent = 'âœ… KopyalandÄ±!';
                        setTimeout(() => {
                            this.textContent = 'Link Kopyala';
                        }, 2000);
                    });
                }
            });
        });

        // Reading progress bar
        const progressBar = document.createElement('div');
        progressBar.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #ef4444, #f97316);
            z-index: 9999;
            transition: width 0.3s ease;
        `;
        document.body.appendChild(progressBar);

        window.addEventListener('scroll', () => {
            const article = document.querySelector('.article-content');
            const articleHeight = article.offsetHeight;
            const windowHeight = window.innerHeight;
            const scrolled = window.scrollY;
            const articleStart = article.offsetTop;
            const articleEnd = articleStart + articleHeight - windowHeight;
            
            if (scrolled >= articleStart && scrolled <= articleEnd) {
                const progress = ((scrolled - articleStart) / (articleEnd - articleStart)) * 100;
                progressBar.style.width = Math.min(100, Math.max(0, progress)) + '%';
            }
        });
    </script>

    <!-- AdSense Optimization -->
    <script src="../../adsense-optimization.js"></script>
    
    <!-- Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-40X5D8K6WH"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-40X5D8K6WH');
    </script>
</body>
</html>