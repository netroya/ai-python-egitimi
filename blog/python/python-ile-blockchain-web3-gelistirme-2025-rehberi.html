<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python ile Blockchain ve Web3 Geliştirme: 2025 Kapsamlı Rehberi | AI & Python</title>
    <meta name="description" content="Python ile blockchain ve Web3 geliştirme öğrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasıl oluşturacağınızı keşfedin.">
    <meta name="keywords" content="python blockchain, web3 python, smart contract python, defi python, nft python, kripto para python, ethereum python, solidity python">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Python ile Blockchain ve Web3 Geliştirme: 2025 Kapsamlı Rehberi">
    <meta property="og:description" content="Python ile blockchain ve Web3 geliştirme öğrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasıl oluşturacağınızı keşfedin.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://netroya.github.io/ai-python-egitimi/blog/python/python-ile-blockchain-web3-gelistirme-2025-rehberi.html">
    
    <!-- Schema.org -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Python ile Blockchain ve Web3 Geliştirme: 2025 Kapsamlı Rehberi",
        "description": "Python ile blockchain ve Web3 geliştirme öğrenin. Smart contract, DeFi, NFT ve kripto para projelerini Python ile nasıl oluşturacağınızı keşfedin.",
        "author": {
            "@type": "Organization",
            "name": "AI & Python Eğitimi"
        },
        "datePublished": "2025-08-20",
        "dateModified": "2025-08-20"
    }
    </script>
    
    <link rel="stylesheet" href="../blog-styles.css">
    <link rel="canonical" href="https://netroya.github.io/ai-python-egitimi/blog/python/python-ile-blockchain-web3-gelistirme-2025-rehberi.html">
    
    <!-- AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9023802833968711" crossorigin="anonymous"></script>
</head>
<body>
    <!-- Header Ad Zone -->
    <div class="ad-zone-header">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="3838714977" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="../../index.html" class="nav-logo">
                <span class="logo-text">PyCode Academy</span>
            </a>
            <div class="nav-menu">
                <a href="../../index.html" class="nav-link">Ana Sayfa</a>
                <a href="../index.html" class="nav-link">Blog</a>
                <a href="index.html" class="nav-link">Python</a>
                <a href="../ai-ml/index.html" class="nav-link">AI & ML</a>
                <a href="../career/index.html" class="nav-link">Kariyer</a>
                <a href="../web-dev/index.html" class="nav-link">Web Dev</a>
            </div>
        </div>
    </nav>

    <main class="blog-container">
        <article class="blog-post">
            <!-- Article Header -->
            <header class="article-header">
                <div class="breadcrumb">
                    <a href="../../index.html">Ana Sayfa</a> > 
                    <a href="../index.html">Blog</a> > 
                    <a href="index.html">Python</a> > 
                    <span>Blockchain & Web3</span>
                </div>
                
                <div class="article-meta">
                    <span class="category blockchain">🔗 Blockchain</span>
                    <span class="category web3">🌐 Web3</span>
                    <span class="read-time">⏱️ 15 dakika okuma</span>
                    <span class="publish-date">📅 20 Ağustos 2025</span>
                    <span class="trend-badge">🔥 TREND</span>
                </div>
                
                <h1>🚀 Python ile Blockchain ve Web3 Geliştirme: 2025 Kapsamlı Rehberi</h1>
                
                <div class="article-intro">
                    <p class="lead">Blockchain teknolojisi ve Web3 dünyası hızla gelişiyor. Python'un güçlü kütüphaneleri ve basit sözdizimi sayesinde blockchain geliştirme hiç bu kadar kolay olmamıştı. Bu kapsamlı rehberde, Python ile smart contract'lardan DeFi uygulamalarına, NFT projelerinden kripto para botlarına kadar her şeyi öğreneceksiniz.</p>
                </div>
                
                <div class="article-highlights">
                    <h3>📋 Bu Makalede Öğrenecekleriniz:</h3>
                    <ul>
                        <li>✅ Python ile blockchain temellerini anlama</li>
                        <li>✅ Web3.py ile Ethereum blockchain'e bağlanma</li>
                        <li>✅ Smart contract geliştirme ve deploy etme</li>
                        <li>✅ DeFi protokolleri ile etkileşim kurma</li>
                        <li>✅ NFT minting ve trading botları</li>
                        <li>✅ Kripto para arbitraj botları</li>
                        <li>✅ Blockchain veri analizi</li>
                        <li>✅ Güvenlik en iyi uygulamaları</li>
                    </ul>
                </div>
            </header>

            <!-- Table of Contents -->
            <div class="table-of-contents">
                <h3>📖 İçindekiler</h3>
                <ol>
                    <li><a href="#blockchain-temelleri">Blockchain ve Web3 Temelleri</a></li>
                    <li><a href="#python-kurulum">Python Geliştirme Ortamı Kurulumu</a></li>
                    <li><a href="#web3py-baslangic">Web3.py ile İlk Adımlar</a></li>
                    <li><a href="#smart-contracts">Smart Contract Geliştirme</a></li>
                    <li><a href="#defi-uygulamalari">DeFi Uygulamaları</a></li>
                    <li><a href="#nft-projeleri">NFT Projeleri</a></li>
                    <li><a href="#trading-botlari">Trading ve Arbitraj Botları</a></li>
                    <li><a href="#veri-analizi">Blockchain Veri Analizi</a></li>
                    <li><a href="#guvenlik">Güvenlik ve En İyi Uygulamalar</a></li>
                    <li><a href="#gelecek-trendler">2025 Trendleri ve Gelecek</a></li>
                </ol>
            </div>

            <!-- Mid-Content Ad -->
            <div class="ad-zone-content">
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9023802833968711" data-ad-slot="4515379030"></ins>
                <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>

            <!-- Article Content -->
            <div class="article-content">
                <section id="blockchain-temelleri">
                    <h2>🧱 1. Blockchain ve Web3 Temelleri</h2>
                    
                    <h3>Blockchain Nedir?</h3>
                    <p>Blockchain, verilerin bloklar halinde zincir şeklinde saklandığı dağıtılmış bir veritabanı teknolojisidir. Her blok, önceki bloğa kriptografik hash ile bağlıdır ve bu sayede değiştirilemez bir kayıt oluşturur.</p>
                    
                    <div class="info-box">
                        <h4>🔑 Blockchain'in Temel Özellikleri:</h4>
                        <ul>
                            <li><strong>Merkeziyetsizlik:</strong> Tek bir otoritenin kontrolü yoktur</li>
                            <li><strong>Şeffaflık:</strong> Tüm işlemler herkese açık görülebilir</li>
                            <li><strong>Değiştirilemezlik:</strong> Onaylanmış işlemler değiştirilemez</li>
                            <li><strong>Güvenlik:</strong> Kriptografik koruma</li>
                        </ul>
                    </div>
                    
                    <h3>Web3 Nedir?</h3>
                    <p>Web3, internetin yeni nesli olarak tanımlanan ve blockchain teknolojisi üzerine inşa edilen merkeziyetsiz web vizyonudur. Kullanıcıların verilerine sahip olduğu ve aracılar olmadan etkileşim kurabildiği bir internet.</p>
                    
                    <div class="code-example">
                        <h4>💡 Web1 vs Web2 vs Web3 Karşılaştırması</h4>
                        <pre><code># Web1: Sadece Okuma (1990-2004)
# - Statik web sayfaları
# - Tek yönlü iletişim
# - HTML tabanlı

# Web2: Okuma + Yazma (2004-günümüz)
# - Sosyal medya platformları
# - Kullanıcı üretimi içerik
# - Merkezi platformlar

# Web3: Okuma + Yazma + Sahiplik (2020+)
# - Merkeziyetsiz uygulamalar (dApps)
# - Kullanıcı veri sahipliği
# - Blockchain tabanlı</code></pre>
                    </div>
                </section>

                <section id="python-kurulum">
                    <h2>⚙️ 2. Python Geliştirme Ortamı Kurulumu</h2>
                    
                    <h3>Gerekli Kütüphaneler</h3>
                    <p>Python ile blockchain geliştirme için aşağıdaki kütüphaneleri kurmanız gerekiyor:</p>
                    
                    <div class="code-example">
                        <pre><code># Temel Web3 kütüphaneleri
pip install web3
pip install eth-account
pip install brownie-eth

# Blockchain veri analizi
pip install pandas
pip install matplotlib
pip install seaborn

# API ve HTTP istekleri
pip install requests
pip install aiohttp

# Matematiksel hesaplamalar
pip install numpy
pip install scipy

# Asenkron programlama
pip install asyncio
pip install websockets</code></pre>
                    </div>
                    
                    <h3>Development Environment Setup</h3>
                    <div class="code-example">
                        <pre><code>from web3 import Web3
import json
import asyncio
from eth_account import Account
import pandas as pd

# Infura veya Alchemy endpoint
INFURA_URL = "https://mainnet.infura.io/v3/YOUR_PROJECT_ID"
w3 = Web3(Web3.HTTPProvider(INFURA_URL))

# Bağlantı testi
if w3.is_connected():
    print("✅ Ethereum ağına başarıyla bağlandı")
    print(f"En son blok numarası: {w3.eth.block_number}")
else:
    print("❌ Bağlantı hatası")</code></pre>
                    </div>
                </section>

                <section id="web3py-baslangic">
                    <h2>🌐 3. Web3.py ile İlk Adımlar</h2>
                    
                    <h3>Ethereum Ağına Bağlanma</h3>
                    <div class="code-example">
                        <pre><code>from web3 import Web3

class EthereumConnector:
    def __init__(self, provider_url):
        self.w3 = Web3(Web3.HTTPProvider(provider_url))
        
    def get_balance(self, address):
        """Adres bakiyesini ETH cinsinden döndür"""
        balance_wei = self.w3.eth.get_balance(address)
        balance_eth = self.w3.from_wei(balance_wei, 'ether')
        return float(balance_eth)
    
    def get_gas_price(self):
        """Güncel gas fiyatını Gwei cinsinden döndür"""
        gas_price_wei = self.w3.eth.gas_price
        gas_price_gwei = self.w3.from_wei(gas_price_wei, 'gwei')
        return float(gas_price_gwei)
    
    def get_transaction(self, tx_hash):
        """İşlem detaylarını getir"""
        try:
            return self.w3.eth.get_transaction(tx_hash)
        except Exception as e:
            print(f"İşlem bulunamadı: {e}")
            return None

# Kullanım
eth = EthereumConnector("https://mainnet.infura.io/v3/YOUR_PROJECT_ID")
vitalik_address = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"
balance = eth.get_balance(vitalik_address)
print(f"Vitalik'in bakiyesi: {balance:.4f} ETH")</code></pre>
                    </div>
                    
                    <h3>Cüzdan İşlemleri</h3>
                    <div class="code-example">
                        <pre><code>from eth_account import Account
import secrets

class WalletManager:
    def __init__(self):
        self.accounts = {}
    
    def create_wallet(self, name):
        """Yeni cüzdan oluştur"""
        # Güvenli private key oluştur
        private_key = "0x" + secrets.token_hex(32)
        account = Account.from_key(private_key)
        
        wallet_info = {
            'address': account.address,
            'private_key': private_key,
            'public_key': account.key.hex()
        }
        
        self.accounts[name] = wallet_info
        return wallet_info
    
    def sign_transaction(self, account_name, transaction):
        """İşlemi imzala"""
        if account_name not in self.accounts:
            raise ValueError("Hesap bulunamadı")
        
        private_key = self.accounts[account_name]['private_key']
        signed_txn = Account.sign_transaction(transaction, private_key)
        return signed_txn
    
    def export_wallet(self, account_name, password):
        """Cüzdanı JSON formatında dışa aktar"""
        if account_name not in self.accounts:
            raise ValueError("Hesap bulunamadı")
        
        private_key = self.accounts[account_name]['private_key']
        encrypted = Account.encrypt(private_key, password)
        return encrypted

# Kullanım
wallet_manager = WalletManager()
new_wallet = wallet_manager.create_wallet("my_wallet")
print(f"Yeni cüzdan adresi: {new_wallet['address']}")</code></pre>
                    </div>
                </section>

                <section id="smart-contracts">
                    <h2>📄 4. Smart Contract Geliştirme</h2>
                    
                    <h3>Solidity ile Smart Contract</h3>
                    <p>Önce basit bir ERC-20 token contract'ı yazalım:</p>
                    
                    <div class="code-example">
                        <h4>🔗 SimpleToken.sol</h4>
                        <pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    string public name = "PyToken";
    string public symbol = "PYT";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * 10**decimals;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}</code></pre>
                    </div>
                    
                    <h3>Python ile Smart Contract Etkileşimi</h3>
                    <div class="code-example">
                        <pre><code>import json
from web3 import Web3

class SmartContractManager:
    def __init__(self, w3, contract_address, abi):
        self.w3 = w3
        self.contract = w3.eth.contract(address=contract_address, abi=abi)
    
    def read_function(self, function_name, *args):
        """Smart contract okuma fonksiyonu çağır"""
        try:
            function = getattr(self.contract.functions, function_name)
            result = function(*args).call()
            return result
        except Exception as e:
            print(f"Okuma hatası: {e}")
            return None
    
    def write_function(self, function_name, private_key, *args, **kwargs):
        """Smart contract yazma fonksiyonu çağır"""
        try:
            # Account bilgilerini al
            account = Account.from_key(private_key)
            
            # Fonksiyonu hazırla
            function = getattr(self.contract.functions, function_name)
            
            # İşlem parametreleri
            transaction = function(*args).build_transaction({
                'from': account.address,
                'gas': kwargs.get('gas', 200000),
                'gasPrice': self.w3.to_wei(kwargs.get('gas_price', 20), 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(account.address),
            })
            
            # İşlemi imzala ve gönder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            return tx_hash.hex()
            
        except Exception as e:
            print(f"Yazma hatası: {e}")
            return None
    
    def get_events(self, event_name, from_block=0, to_block='latest'):
        """Contract event'lerini getir"""
        try:
            event_filter = getattr(self.contract.events, event_name).create_filter(
                fromBlock=from_block, 
                toBlock=to_block
            )
            return event_filter.get_all_entries()
        except Exception as e:
            print(f"Event okuma hatası: {e}")
            return []

# ERC-20 Token yönetimi örneği
class TokenManager(SmartContractManager):
    def get_balance(self, address):
        """Token bakiyesi"""
        balance = self.read_function('balanceOf', address)
        return balance / (10 ** self.get_decimals()) if balance else 0
    
    def get_total_supply(self):
        """Toplam arz"""
        return self.read_function('totalSupply')
    
    def get_decimals(self):
        """Token ondalık sayısı"""
        return self.read_function('decimals')
    
    def transfer_tokens(self, private_key, to_address, amount):
        """Token transfer et"""
        decimals = self.get_decimals()
        amount_with_decimals = int(amount * (10 ** decimals))
        
        return self.write_function(
            'transfer', 
            private_key, 
            to_address, 
            amount_with_decimals
        )</code></pre>
                    </div>
                </section>

                <section id="defi-uygulamalari">
                    <h2>💰 5. DeFi Uygulamaları</h2>
                    
                    <h3>Uniswap ile Token Swap</h3>
                    <div class="code-example">
                        <pre><code>import json
from web3 import Web3

class UniswapV3Manager:
    def __init__(self, w3):
        self.w3 = w3
        self.router_address = "0xE592427A0AEce92De3Edee1F18E0157C05861564"
        self.router_abi = [
            # Uniswap V3 Router ABI (kısaltılmış)
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenIn", "type": "address"},
                    {"internalType": "address", "name": "tokenOut", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "address", "name": "recipient", "type": "address"},
                    {"internalType": "uint256", "name": "deadline", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountOutMinimum", "type": "uint256"},
                    {"internalType": "uint160", "name": "sqrtPriceLimitX96", "type": "uint160"}
                ],
                "name": "exactInputSingle",
                "outputs": [{"internalType": "uint256", "name": "amountOut", "type": "uint256"}],
                "stateMutability": "payable",
                "type": "function"
            }
        ]
        self.router = w3.eth.contract(address=self.router_address, abi=self.router_abi)
    
    def get_token_price(self, token_address):
        """Token fiyatını USD cinsinden getir (CoinGecko API)"""
        import requests
        
        try:
            url = f"https://api.coingecko.com/api/v3/simple/token_price/ethereum"
            params = {
                'contract_addresses': token_address,
                'vs_currencies': 'usd'
            }
            response = requests.get(url, params=params)
            data = response.json()
            
            return data.get(token_address.lower(), {}).get('usd', 0)
        except Exception as e:
            print(f"Fiyat alma hatası: {e}")
            return 0
    
    def calculate_slippage(self, amount_in, amount_out_min, slippage_tolerance=0.5):
        """Slippage hesapla"""
        expected_amount = amount_in * 0.997  # %0.3 fee varsayımı
        actual_slippage = ((expected_amount - amount_out_min) / expected_amount) * 100
        
        return {
            'expected_amount': expected_amount,
            'minimum_received': amount_out_min,
            'slippage_percent': actual_slippage,
            'within_tolerance': actual_slippage <= slippage_tolerance
        }
    
    def swap_tokens(self, private_key, token_in, token_out, amount_in, slippage=0.5):
        """Token swap işlemi"""
        try:
            account = Account.from_key(private_key)
            
            # Deadline (10 dakika sonra)
            deadline = int(time.time()) + 600
            
            # Minimum çıkış miktarı (slippage dahil)
            amount_out_min = int(amount_in * (1 - slippage/100) * 0.997)
            
            # Swap parametreleri
            params = {
                'tokenIn': token_in,
                'tokenOut': token_out,
                'fee': 3000,  # 0.3% fee pool
                'recipient': account.address,
                'deadline': deadline,
                'amountIn': amount_in,
                'amountOutMinimum': amount_out_min,
                'sqrtPriceLimitX96': 0
            }
            
            # İşlem oluştur
            transaction = self.router.functions.exactInputSingle(params).build_transaction({
                'from': account.address,
                'gas': 300000,
                'gasPrice': self.w3.to_wei(30, 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(account.address),
                'value': amount_in if token_in == "0x0000000000000000000000000000000000000000" else 0
            })
            
            # İmzala ve gönder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            return tx_hash.hex()
            
        except Exception as e:
            print(f"Swap hatası: {e}")
            return None</code></pre>
                    </div>
                    
                    <h3>Yield Farming Bot</h3>
                    <div class="code-example">
                        <pre><code>import asyncio
import time
from datetime import datetime

class YieldFarmingBot:
    def __init__(self, w3, private_key):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        self.farming_pools = []
        self.min_apy = 15.0  # Minimum %15 APY
        
    def add_farming_pool(self, pool_address, token_pair, current_apy):
        """Farming pool ekle"""
        pool_info = {
            'address': pool_address,
            'token_pair': token_pair,
            'current_apy': current_apy,
            'last_check': time.time(),
            'is_farming': False
        }
        self.farming_pools.append(pool_info)
    
    async def monitor_pools(self):
        """Pool'ları sürekli izle"""
        while True:
            try:
                for pool in self.farming_pools:
                    current_apy = await self.get_pool_apy(pool['address'])
                    pool['current_apy'] = current_apy
                    
                    # APY yeterince yüksekse farm et
                    if current_apy >= self.min_apy and not pool['is_farming']:
                        await self.start_farming(pool)
                    
                    # APY düştüyse çık
                    elif current_apy < self.min_apy and pool['is_farming']:
                        await self.stop_farming(pool)
                    
                    pool['last_check'] = time.time()
                
                # 5 dakika bekle
                await asyncio.sleep(300)
                
            except Exception as e:
                print(f"Monitoring hatası: {e}")
                await asyncio.sleep(60)
    
    async def get_pool_apy(self, pool_address):
        """Pool APY hesapla"""
        # Bu fonksiyon gerçek pool verilerini analiz eder
        # Örnek basit hesaplama
        try:
            # Pool contract'ından veri çek
            # Gerçek implementasyonda pool-specific hesaplamalar yapılır
            base_apy = 12.5
            volatility_bonus = 2.5
            return base_apy + volatility_bonus
        except:
            return 0
    
    async def start_farming(self, pool):
        """Farming başlat"""
        try:
            print(f"🚀 Farming başlatılıyor: {pool['token_pair']} (APY: {pool['current_apy']:.2f}%)")
            
            # Liquidity provide et
            # Bu örnekte basitleştirilmiş
            pool['is_farming'] = True
            
            # Log kaydet
            with open('farming_log.txt', 'a') as f:
                f.write(f"{datetime.now()}: Started farming {pool['token_pair']} at {pool['current_apy']:.2f}% APY\n")
                
        except Exception as e:
            print(f"Farming başlatma hatası: {e}")
    
    async def stop_farming(self, pool):
        """Farming durdur"""
        try:
            print(f"🛑 Farming durduruluyor: {pool['token_pair']} (APY düştü: {pool['current_apy']:.2f}%)")
            
            # Liquidity withdraw et
            pool['is_farming'] = False
            
            # Kazancı hesapla ve log'la
            with open('farming_log.txt', 'a') as f:
                f.write(f"{datetime.now()}: Stopped farming {pool['token_pair']} at {pool['current_apy']:.2f}% APY\n")
                
        except Exception as e:
            print(f"Farming durdurma hatası: {e}")

# Kullanım
async def main():
    bot = YieldFarmingBot(w3, "YOUR_PRIVATE_KEY")
    
    # Pool'ları ekle
    bot.add_farming_pool("0x...", "ETH/USDC", 18.5)
    bot.add_farming_pool("0x...", "ETH/DAI", 16.2)
    
    # Monitoring başlat
    await bot.monitor_pools()

# asyncio.run(main())</code></pre>
                    </div>
                </section>

                <section id="nft-projeleri">
                    <h2>🎨 6. NFT Projeleri</h2>
                    
                    <h3>NFT Minting Bot</h3>
                    <div class="code-example">
                        <pre><code>import requests
import json
from PIL import Image
import hashlib

class NFTMintingBot:
    def __init__(self, w3, private_key, contract_address):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        self.contract_address = contract_address
        
        # ERC-721 ABI (basitleştirilmiş)
        self.nft_abi = [
            {
                "inputs": [
                    {"name": "to", "type": "address"},
                    {"name": "tokenURI", "type": "string"}
                ],
                "name": "mint",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ]
        
        self.contract = w3.eth.contract(address=contract_address, abi=self.nft_abi)
    
    def upload_to_ipfs(self, file_path, metadata):
        """Dosyayı IPFS'e yükle"""
        try:
            # Pinata API kullanarak IPFS'e yükleme
            pinata_api_key = "YOUR_PINATA_API_KEY"
            pinata_secret_key = "YOUR_PINATA_SECRET_KEY"
            
            # Görsel yükle
            with open(file_path, 'rb') as file:
                files = {'file': file}
                headers = {
                    'pinata_api_key': pinata_api_key,
                    'pinata_secret_api_key': pinata_secret_key
                }
                
                response = requests.post(
                    'https://api.pinata.cloud/pinning/pinFileToIPFS',
                    files=files,
                    headers=headers
                )
                
                if response.status_code == 200:
                    image_hash = response.json()['IpfsHash']
                    
                    # Metadata'yı hazırla
                    nft_metadata = {
                        "name": metadata['name'],
                        "description": metadata['description'],
                        "image": f"ipfs://{image_hash}",
                        "attributes": metadata.get('attributes', [])
                    }
                    
                    # Metadata'yı IPFS'e yükle
                    metadata_response = requests.post(
                        'https://api.pinata.cloud/pinning/pinJSONToIPFS',
                        json=nft_metadata,
                        headers=headers
                    )
                    
                    if metadata_response.status_code == 200:
                        metadata_hash = metadata_response.json()['IpfsHash']
                        return f"ipfs://{metadata_hash}"
                
        except Exception as e:
            print(f"IPFS yükleme hatası: {e}")
            return None
    
    def generate_art(self, traits):
        """Programmatik NFT art oluştur"""
        try:
            from PIL import Image, ImageDraw
            import random
            
            # 1000x1000 canvas
            img = Image.new('RGB', (1000, 1000), color='white')
            draw = ImageDraw.Draw(img)
            
            # Arka plan
            bg_color = random.choice(['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'])
            draw.rectangle([0, 0, 1000, 1000], fill=bg_color)
            
            # Şekiller ekle
            for _ in range(random.randint(3, 8)):
                x = random.randint(0, 800)
                y = random.randint(0, 800)
                size = random.randint(50, 200)
                color = random.choice(['#FFFFFF', '#000000', '#FF4757', '#2ED573'])
                
                if random.choice([True, False]):
                    # Daire
                    draw.ellipse([x, y, x+size, y+size], fill=color)
                else:
                    # Kare
                    draw.rectangle([x, y, x+size, y+size], fill=color)
            
            # Unique hash oluştur
            img_hash = hashlib.md5(str(traits).encode()).hexdigest()
            filename = f"generated_nft_{img_hash}.png"
            img.save(filename)
            
            return filename
            
        except Exception as e:
            print(f"Art oluşturma hatası: {e}")
            return None
    
    def mint_nft(self, recipient, metadata):
        """NFT mint et"""
        try:
            # Art oluştur
            traits = {
                'background': metadata.get('background', 'blue'),
                'shape_count': metadata.get('shape_count', 5),
                'color_scheme': metadata.get('color_scheme', 'vibrant')
            }
            
            art_file = self.generate_art(traits)
            if not art_file:
                return None
            
            # IPFS'e yükle
            token_uri = self.upload_to_ipfs(art_file, metadata)
            if not token_uri:
                return None
            
            # Mint işlemi
            transaction = self.contract.functions.mint(
                recipient, 
                token_uri
            ).build_transaction({
                'from': self.account.address,
                'gas': 200000,
                'gasPrice': self.w3.to_wei(20, 'gwei'),
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            # İmzala ve gönder
            signed_txn = self.w3.eth.account.sign_transaction(transaction, self.private_key)
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            print(f"✅ NFT mint edildi! TX: {tx_hash.hex()}")
            print(f"📁 Metadata URI: {token_uri}")
            
            return {
                'tx_hash': tx_hash.hex(),
                'token_uri': token_uri,
                'art_file': art_file
            }
            
        except Exception as e:
            print(f"Mint hatası: {e}")
            return None
    
    def batch_mint(self, recipients, base_metadata, count=10):
        """Toplu NFT mint et"""
        results = []
        
        for i in range(count):
            recipient = recipients[i % len(recipients)]
            
            # Her NFT için unique metadata
            metadata = base_metadata.copy()
            metadata['name'] = f"{metadata['name']} #{i+1}"
            metadata['attributes'].append({
                'trait_type': 'Generation',
                'value': f'Gen {i+1}'
            })
            
            result = self.mint_nft(recipient, metadata)
            if result:
                results.append(result)
                
            # Rate limiting
            time.sleep(2)
        
        return results

# Kullanım
bot = NFTMintingBot(w3, "YOUR_PRIVATE_KEY", "NFT_CONTRACT_ADDRESS")

metadata = {
    'name': 'Generated Art Collection',
    'description': 'Algorithmically generated unique digital art',
    'attributes': [
        {'trait_type': 'Type', 'value': 'Generative'},
        {'trait_type': 'Rarity', 'value': 'Common'}
    ]
}

# Tek NFT mint et
result = bot.mint_nft("0x...", metadata)</code></pre>
                    </div>
                    
                    <h3>NFT Rarity Analyzer</h3>
                    <div class="code-example">
                        <pre><code>import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter

class NFTRarityAnalyzer:
    def __init__(self, collection_address):
        self.collection_address = collection_address
        self.nft_data = []
        self.trait_rarity = {}
    
    def fetch_collection_data(self):
        """OpenSea API'sinden koleksiyon verilerini çek"""
        try:
            import requests
            
            url = f"https://api.opensea.io/api/v1/assets"
            params = {
                'asset_contract_address': self.collection_address,
                'order_direction': 'desc',
                'offset': 0,
                'limit': 200
            }
            
            all_nfts = []
            offset = 0
            
            while len(all_nfts) < 1000:  # Max 1000 NFT analiz et
                params['offset'] = offset
                response = requests.get(url, params=params)
                
                if response.status_code == 200:
                    data = response.json()
                    assets = data.get('assets', [])
                    
                    if not assets:
                        break
                    
                    all_nfts.extend(assets)
                    offset += 200
                else:
                    break
            
            self.nft_data = all_nfts
            return len(all_nfts)
            
        except Exception as e:
            print(f"Veri çekme hatası: {e}")
            return 0
    
    def analyze_traits(self):
        """Trait rarity analizi yap"""
        trait_counts = {}
        total_nfts = len(self.nft_data)
        
        for nft in self.nft_data:
            traits = nft.get('traits', [])
            
            for trait in traits:
                trait_type = trait.get('trait_type')
                trait_value = trait.get('value')
                
                if trait_type and trait_value:
                    key = f"{trait_type}:{trait_value}"
                    trait_counts[key] = trait_counts.get(key, 0) + 1
        
        # Rarity skorlarını hesapla
        self.trait_rarity = {}
        for trait, count in trait_counts.items():
            rarity_score = (total_nfts - count) / total_nfts * 100
            self.trait_rarity[trait] = {
                'count': count,
                'rarity_score': rarity_score,
                'percentage': (count / total_nfts) * 100
            }
        
        return self.trait_rarity
    
    def calculate_nft_rarity(self, token_id):
        """Belirli bir NFT'nin rarity skorunu hesapla"""
        nft = next((n for n in self.nft_data if n.get('token_id') == str(token_id)), None)
        
        if not nft:
            return None
        
        total_rarity_score = 0
        trait_details = []
        
        for trait in nft.get('traits', []):
            trait_type = trait.get('trait_type')
            trait_value = trait.get('value')
            key = f"{trait_type}:{trait_value}"
            
            if key in self.trait_rarity:
                rarity_info = self.trait_rarity[key]
                total_rarity_score += rarity_info['rarity_score']
                
                trait_details.append({
                    'trait_type': trait_type,
                    'value': trait_value,
                    'rarity_score': rarity_info['rarity_score'],
                    'percentage': rarity_info['percentage']
                })
        
        return {
            'token_id': token_id,
            'total_rarity_score': total_rarity_score,
            'trait_count': len(trait_details),
            'traits': trait_details,
            'rank': self.get_rarity_rank(total_rarity_score)
        }
    
    def get_rarity_rank(self, rarity_score):
        """Rarity skoru'na göre rank belirle"""
        all_scores = []
        
        for nft in self.nft_data:
            nft_score = 0
            for trait in nft.get('traits', []):
                trait_type = trait.get('trait_type')
                trait_value = trait.get('value')
                key = f"{trait_type}:{trait_value}"
                
                if key in self.trait_rarity:
                    nft_score += self.trait_rarity[key]['rarity_score']
            
            all_scores.append(nft_score)
        
        all_scores.sort(reverse=True)
        
        try:
            rank = all_scores.index(rarity_score) + 1
            return rank
        except ValueError:
            return len(all_scores) + 1
    
    def generate_rarity_report(self):
        """Rarity raporunu oluştur"""
        if not self.trait_rarity:
            self.analyze_traits()
        
        # En nadir trait'leri bul
        rarest_traits = sorted(
            self.trait_rarity.items(), 
            key=lambda x: x[1]['rarity_score'], 
            reverse=True
        )[:10]
        
        # Rapor oluştur
        report = {
            'collection_address': self.collection_address,
            'total_nfts': len(self.nft_data),
            'total_traits': len(self.trait_rarity),
            'rarest_traits': rarest_traits,
            'analysis_date': pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        return report
    
    def plot_rarity_distribution(self):
        """Rarity dağılımını görselleştir"""
        scores = [info['rarity_score'] for info in self.trait_rarity.values()]
        
        plt.figure(figsize=(12, 6))
        
        plt.subplot(1, 2, 1)
        plt.hist(scores, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
        plt.title('Trait Rarity Score Distribution')
        plt.xlabel('Rarity Score')
        plt.ylabel('Frequency')
        
        plt.subplot(1, 2, 2)
        plt.boxplot(scores)
        plt.title('Rarity Score Box Plot')
        plt.ylabel('Rarity Score')
        
        plt.tight_layout()
        plt.savefig('rarity_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()

# Kullanım
analyzer = NFTRarityAnalyzer("0x...")  # Collection address
nft_count = analyzer.fetch_collection_data()
print(f"Analiz edilen NFT sayısı: {nft_count}")

analyzer.analyze_traits()
rarity_info = analyzer.calculate_nft_rarity("1234")
print(f"NFT #1234 rarity bilgisi: {rarity_info}")

report = analyzer.generate_rarity_report()
analyzer.plot_rarity_distribution()</code></pre>
                    </div>
                </section>

                <section id="trading-botlari">
                    <h2>🤖 7. Trading ve Arbitraj Botları</h2>
                    
                    <h3>Multi-DEX Arbitraj Botu</h3>
                    <div class="code-example">
                        <pre><code>import asyncio
import aiohttp
from decimal import Decimal
import time

class ArbitrageBot:
    def __init__(self, w3, private_key):
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        
        # DEX'ler
        self.exchanges = {
            'uniswap_v2': {
                'router': '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
                'fee': 0.3
            },
            'sushiswap': {
                'router': '0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F',
                'fee': 0.3
            },
            'uniswap_v3': {
                'router': '0xE592427A0AEce92De3Edee1F18E0157C05861564',
                'fee': 0.3
            }
        }
        
        # İzlenecek token çiftleri
        self.token_pairs = [
            ('WETH', 'USDC'),
            ('WETH', 'DAI'),
            ('USDC', 'DAI'),
            ('WETH', 'USDT')
        ]
        
        self.min_profit_threshold = 50  # Minimum $50 kar
        self.max_slippage = 0.5  # %0.5 maksimum slippage
    
    async def get_token_price(self, session, exchange, token_in, token_out, amount_in):
        """Belirli bir DEX'teki token fiyatını al"""
        try:
            if exchange == 'uniswap_v2':
                return await self.get_uniswap_v2_price(session, token_in, token_out, amount_in)
            elif exchange == 'sushiswap':
                return await self.get_sushiswap_price(session, token_in, token_out, amount_in)
            elif exchange == 'uniswap_v3':
                return await self.get_uniswap_v3_price(session, token_in, token_out, amount_in)
            
        except Exception as e:
            print(f"Fiyat alma hatası ({exchange}): {e}")
            return None
    
    async def get_uniswap_v2_price(self, session, token_in, token_out, amount_in):
        """Uniswap V2 fiyatını al"""
        try:
            # Simplified - gerçek implementasyonda pair contract'ını çağırır
            url = f"https://api.uniswap.org/v2/quote"
            params = {
                'tokenIn': token_in,
                'tokenOut': token_out,
                'amountIn': amount_in
            }
            
            async with session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    return {
                        'exchange': 'uniswap_v2',
                        'amount_out': float(data.get('amountOut', 0)),
                        'gas_estimate': 150000,
                        'fee': self.exchanges['uniswap_v2']['fee']
                    }
        except:
            pass
        
        return None
    
    async def find_arbitrage_opportunities(self):
        """Arbitraj fırsatlarını bul"""
        opportunities = []
        
        async with aiohttp.ClientSession() as session:
            for token_pair in self.token_pairs:
                token_in, token_out = token_pair
                amount_in = 1000  # $1000 test miktarı
                
                # Tüm DEX'lerdeki fiyatları al
                prices = {}
                for exchange in self.exchanges.keys():
                    price = await self.get_token_price(session, exchange, token_in, token_out, amount_in)
                    if price:
                        prices[exchange] = price
                
                # Arbitraj fırsatı var mı kontrol et
                if len(prices) >= 2:
                    # En düşük ve en yüksek fiyatı bul
                    buy_exchange = min(prices.keys(), key=lambda x: prices[x]['amount_out'])
                    sell_exchange = max(prices.keys(), key=lambda x: prices[x]['amount_out'])
                    
                    buy_price = prices[buy_exchange]['amount_out']
                    sell_price = prices[sell_exchange]['amount_out']
                    
                    # Profit hesapla
                    gross_profit = sell_price - buy_price
                    
                    # Gas maliyetlerini çıkar
                    total_gas = prices[buy_exchange]['gas_estimate'] + prices[sell_exchange]['gas_estimate']
                    gas_cost = total_gas * self.w3.to_wei(30, 'gwei') / 10**18 * 2000  # ETH fiyatı $2000 varsayımı
                    
                    # Swap fee'lerini çıkar
                    total_fees = (prices[buy_exchange]['fee'] + prices[sell_exchange]['fee']) / 100 * amount_in
                    
                    net_profit = gross_profit - gas_cost - total_fees
                    
                    if net_profit > self.min_profit_threshold:
                        opportunity = {
                            'token_pair': token_pair,
                            'buy_exchange': buy_exchange,
                            'sell_exchange': sell_exchange,
                            'buy_price': buy_price,
                            'sell_price': sell_price,
                            'gross_profit': gross_profit,
                            'gas_cost': gas_cost,
                            'fees': total_fees,
                            'net_profit': net_profit,
                            'profit_percentage': (net_profit / amount_in) * 100,
                            'timestamp': time.time()
                        }
                        opportunities.append(opportunity)
        
        return opportunities
    
    async def execute_arbitrage(self, opportunity):
        """Arbitraj işlemini gerçekleştir"""
        try:
            print(f"🚀 Arbitraj işlemi başlatılıyor...")
            print(f"Token Pair: {opportunity['token_pair']}")
            print(f"Buy: {opportunity['buy_exchange']} - Sell: {opportunity['sell_exchange']}")
            print(f"Beklenen kar: ${opportunity['net_profit']:.2f}")
            
            # 1. İlk DEX'te satın al
            buy_tx = await self.execute_swap(
                opportunity['buy_exchange'],
                opportunity['token_pair'][0],
                opportunity['token_pair'][1],
                1000  # $1000
            )
            
            if not buy_tx:
                print("❌ Satın alma işlemi başarısız")
                return False
            
            # Transaction confirm olmasını bekle
            receipt = self.w3.eth.wait_for_transaction_receipt(buy_tx)
            if receipt.status != 1:
                print("❌ Satın alma transaction'ı başarısız")
                return False
            
            # 2. İkinci DEX'te sat
            sell_tx = await self.execute_swap(
                opportunity['sell_exchange'],
                opportunity['token_pair'][1],
                opportunity['token_pair'][0],
                opportunity['buy_price']
            )
            
            if not sell_tx:
                print("❌ Satış işlemi başarısız")
                return False
            
            # Transaction confirm olmasını bekle
            receipt = self.w3.eth.wait_for_transaction_receipt(sell_tx)
            if receipt.status == 1:
                print("✅ Arbitraj işlemi başarıyla tamamlandı!")
                
                # Sonuçları logla
                with open('arbitrage_log.txt', 'a') as f:
                    f.write(f"{time.ctime()}: Successful arbitrage - Profit: ${opportunity['net_profit']:.2f}\n")
                
                return True
            else:
                print("❌ Satış transaction'ı başarısız")
                return False
                
        except Exception as e:
            print(f"Arbitraj hatası: {e}")
            return False
    
    async def execute_swap(self, exchange, token_in, token_out, amount):
        """Swap işlemini gerçekleştir"""
        try:
            # Bu fonksiyon gerçek DEX router'larını çağırır
            # Her DEX için farklı implementation gerekir
            
            router_address = self.exchanges[exchange]['router']
            
            # Simplified swap logic
            # Gerçek implementasyonda ERC-20 approve + swap yapılır
            
            return "0x..." + "mock_tx_hash"  # Mock transaction hash
            
        except Exception as e:
            print(f"Swap hatası: {e}")
            return None
    
    async def run_bot(self):
        """Bot'u sürekli çalıştır"""
        print("🤖 Arbitraj botu başlatıldı...")
        
        while True:
            try:
                # Arbitraj fırsatlarını bul
                opportunities = await self.find_arbitrage_opportunities()
                
                if opportunities:
                    print(f"💰 {len(opportunities)} arbitraj fırsatı bulundu!")
                    
                    # En karlı fırsatı seç
                    best_opportunity = max(opportunities, key=lambda x: x['net_profit'])
                    
                    print(f"En iyi fırsat: ${best_opportunity['net_profit']:.2f} kar")
                    
                    # Arbitraj işlemini gerçekleştir
                    if best_opportunity['net_profit'] > self.min_profit_threshold:
                        success = await self.execute_arbitrage(best_opportunity)
                        
                        if success:
                            # Başarılı işlemden sonra biraz bekle
                            await asyncio.sleep(30)
                else:
                    print("📊 Arbitraj fırsatı bulunamadı")
                
                # 10 saniye bekle
                await asyncio.sleep(10)
                
            except Exception as e:
                print(f"Bot hatası: {e}")
                await asyncio.sleep(60)

# Kullanım
async def main():
    bot = ArbitrageBot(w3, "YOUR_PRIVATE_KEY")
    await bot.run_bot()

# asyncio.run(main())</code></pre>
                    </div>
                </section>

                <section id="veri-analizi">
                    <h2>📊 8. Blockchain Veri Analizi</h2>
                    
                    <h3>On-Chain Veri Analizi</h3>
                    <div class="code-example">
                        <pre><code>import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import numpy as np

class BlockchainAnalyzer:
    def __init__(self, w3):
        self.w3 = w3
        self.df_transactions = pd.DataFrame()
        self.df_blocks = pd.DataFrame()
    
    def fetch_recent_blocks(self, block_count=1000):
        """Son N bloğu çek ve analiz et"""
        try:
            latest_block = self.w3.eth.block_number
            blocks_data = []
            
            print(f"📥 Son {block_count} blok çekiliyor...")
            
            for i in range(block_count):
                block_number = latest_block - i
                block = self.w3.eth.get_block(block_number, full_transactions=True)
                
                block_data = {
                    'block_number': block.number,
                    'timestamp': datetime.fromtimestamp(block.timestamp),
                    'transaction_count': len(block.transactions),
                    'gas_used': block.gasUsed,
                    'gas_limit': block.gasLimit,
                    'gas_utilization': (block.gasUsed / block.gasLimit) * 100,
                    'base_fee': block.get('baseFeePerGas', 0),
                    'size': block.size,
                    'difficulty': block.difficulty
                }
                
                blocks_data.append(block_data)
                
                if i % 100 == 0:
                    print(f"İşlenen blok sayısı: {i+1}")
            
            self.df_blocks = pd.DataFrame(blocks_data)
            return len(blocks_data)
            
        except Exception as e:
            print(f"Blok çekme hatası: {e}")
            return 0
    
    def analyze_gas_trends(self):
        """Gas trendlerini analiz et"""
        if self.df_blocks.empty:
            return None
        
        # Gas fiyat trendleri
        self.df_blocks['hour'] = self.df_blocks['timestamp'].dt.hour
        hourly_gas = self.df_blocks.groupby('hour').agg({
            'base_fee': 'mean',
            'gas_utilization': 'mean',
            'transaction_count': 'mean'
        }).round(2)
        
        # Görselleştirme
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # Gas fiyat trendi
        axes[0, 0].plot(self.df_blocks['timestamp'], self.df_blocks['base_fee'])
        axes[0, 0].set_title('Gas Base Fee Trendi')
        axes[0, 0].set_xlabel('Zaman')
        axes[0, 0].set_ylabel('Base Fee (Gwei)')
        
        # Gas kullanım oranı
        axes[0, 1].plot(self.df_blocks['timestamp'], self.df_blocks['gas_utilization'])
        axes[0, 1].set_title('Gas Kullanım Oranı')
        axes[0, 1].set_xlabel('Zaman')
        axes[0, 1].set_ylabel('Kullanım Oranı (%)')
        
        # Saatlik gas fiyatları
        axes[1, 0].bar(hourly_gas.index, hourly_gas['base_fee'])
        axes[1, 0].set_title('Saatlik Ortalama Gas Fiyatları')
        axes[1, 0].set_xlabel('Saat')
        axes[1, 0].set_ylabel('Base Fee (Gwei)')
        
        # Transaction sayısı vs Gas fiyatı
        axes[1, 1].scatter(self.df_blocks['transaction_count'], self.df_blocks['base_fee'], alpha=0.6)
        axes[1, 1].set_title('Transaction Sayısı vs Gas Fiyatı')
        axes[1, 1].set_xlabel('Transaction Sayısı')
        axes[1, 1].set_ylabel('Base Fee (Gwei)')
        
        plt.tight_layout()
        plt.savefig('gas_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return {
            'hourly_stats': hourly_gas,
            'peak_hours': hourly_gas['base_fee'].nlargest(3).index.tolist(),
            'low_hours': hourly_gas['base_fee'].nsmallest(3).index.tolist(),
            'avg_gas_price': self.df_blocks['base_fee'].mean(),
            'avg_utilization': self.df_blocks['gas_utilization'].mean()
        }
    
    def analyze_whale_movements(self, min_value_eth=100):
        """Whale hareketlerini analiz et"""
        try:
            whale_transactions = []
            
            # Son 100 bloktaki büyük transferleri bul
            for _, block_info in self.df_blocks.head(100).iterrows():
                block = self.w3.eth.get_block(block_info['block_number'], full_transactions=True)
                
                for tx in block.transactions:
                    if tx.value > 0:
                        value_eth = self.w3.from_wei(tx.value, 'ether')
                        
                        if value_eth >= min_value_eth:
                            whale_tx = {
                                'hash': tx.hash.hex(),
                                'from': tx['from'],
                                'to': tx.to,
                                'value_eth': float(value_eth),
                                'gas_price': tx.gasPrice,
                                'timestamp': block_info['timestamp'],
                                'block_number': block_info['block_number']
                            }
                            whale_transactions.append(whale_tx)
            
            if whale_transactions:
                df_whales = pd.DataFrame(whale_transactions)
                
                # Whale analizi
                whale_stats = {
                    'total_whale_txs': len(df_whales),
                    'total_value_moved': df_whales['value_eth'].sum(),
                    'avg_whale_tx_size': df_whales['value_eth'].mean(),
                    'largest_tx': df_whales.loc[df_whales['value_eth'].idxmax()],
                    'top_whale_addresses': df_whales.groupby('from')['value_eth'].sum().nlargest(5)
                }
                
                # Whale aktivite grafiği
                plt.figure(figsize=(12, 6))
                plt.scatter(df_whales['timestamp'], df_whales['value_eth'], 
                           alpha=0.7, s=50, c='red')
                plt.title(f'Whale Aktivitesi (>{min_value_eth} ETH)')
                plt.xlabel('Zaman')
                plt.ylabel('Transfer Miktarı (ETH)')
                plt.yscale('log')
                plt.grid(True, alpha=0.3)
                plt.tight_layout()
                plt.savefig('whale_activity.png', dpi=300, bbox_inches='tight')
                plt.show()
                
                return whale_stats
            
        except Exception as e:
            print(f"Whale analizi hatası: {e}")
            return None
    
    def predict_gas_prices(self):
        """Gas fiyatlarını makine öğrenmesi ile tahmin et"""
        try:
            from sklearn.linear_model import LinearRegression
            from sklearn.ensemble import RandomForestRegressor
            from sklearn.metrics import mean_absolute_error, r2_score
            from sklearn.preprocessing import StandardScaler
            
            if len(self.df_blocks) < 100:
                print("Yeterli veri yok")
                return None
            
            # Feature engineering
            self.df_blocks['hour'] = self.df_blocks['timestamp'].dt.hour
            self.df_blocks['day_of_week'] = self.df_blocks['timestamp'].dt.dayofweek
            self.df_blocks['is_weekend'] = self.df_blocks['day_of_week'].isin([5, 6]).astype(int)
            
            # Features
            features = [
                'gas_utilization', 'transaction_count', 'hour', 
                'day_of_week', 'is_weekend', 'difficulty'
            ]
            
            # Veriyi hazırla
            X = self.df_blocks[features].fillna(0)
            y = self.df_blocks['base_fee']
            
            # Train/test split
            split_idx = int(len(X) * 0.8)
            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]
            
            # Model eğitimi
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            # Random Forest modeli
            rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
            rf_model.fit(X_train_scaled, y_train)
            
            # Tahminler
            y_pred = rf_model.predict(X_test_scaled)
            
            # Model performansı
            mae = mean_absolute_error(y_test, y_pred)
            r2 = r2_score(y_test, y_pred)
            
            # Feature importance
            feature_importance = pd.DataFrame({
                'feature': features,
                'importance': rf_model.feature_importances_
            }).sort_values('importance', ascending=False)
            
            # Sonuçları görselleştir
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))
            
            # Tahmin vs Gerçek
            axes[0].scatter(y_test, y_pred, alpha=0.6)
            axes[0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
            axes[0].set_xlabel('Gerçek Gas Fiyatı')
            axes[0].set_ylabel('Tahmin Edilen Gas Fiyatı')
            axes[0].set_title(f'Gas Fiyat Tahmini (R²: {r2:.3f})')
            
            # Feature importance
            axes[1].barh(feature_importance['feature'], feature_importance['importance'])
            axes[1].set_xlabel('Önem Skoru')
            axes[1].set_title('Feature Importance')
            
            plt.tight_layout()
            plt.savefig('gas_prediction.png', dpi=300, bbox_inches='tight')
            plt.show()
            
            # Gelecek saatler için tahmin
            future_predictions = []
            current_hour = datetime.now().hour
            
            for hour_offset in range(1, 25):  # Sonraki 24 saat
                future_hour = (current_hour + hour_offset) % 24
                
                # Ortalama değerleri kullan
                avg_utilization = self.df_blocks['gas_utilization'].mean()
                avg_tx_count = self.df_blocks['transaction_count'].mean()
                avg_difficulty = self.df_blocks['difficulty'].mean()
                
                future_features = [
                    avg_utilization,
                    avg_tx_count,
                    future_hour,
                    datetime.now().weekday(),
                    1 if datetime.now().weekday() in [5, 6] else 0,
                    avg_difficulty
                ]
                
                future_scaled = scaler.transform([future_features])
                predicted_gas = rf_model.predict(future_scaled)[0]
                
                future_predictions.append({
                    'hour_offset': hour_offset,
                    'predicted_hour': future_hour,
                    'predicted_gas_price': predicted_gas
                })
            
            return {
                'model_performance': {'mae': mae, 'r2': r2},
                'feature_importance': feature_importance,
                'future_predictions': future_predictions,
                'best_hours_to_transact': sorted(future_predictions, key=lambda x: x['predicted_gas_price'])[:3]
            }
            
        except Exception as e:
            print(f"Tahmin hatası: {e}")
            return None

# Kullanım
analyzer = BlockchainAnalyzer(w3)

# Veri toplama
block_count = analyzer.fetch_recent_blocks(500)
print(f"Toplanan blok sayısı: {block_count}")

# Gas analizi
gas_analysis = analyzer.analyze_gas_trends()
print("Gas Analizi:", gas_analysis)

# Whale analizi
whale_analysis = analyzer.analyze_whale_movements(min_value_eth=50)
print("Whale Analizi:", whale_analysis)

# Gas fiyat tahmini
prediction_results = analyzer.predict_gas_prices()
print("Tahmin Sonuçları:", prediction_results)</code></pre>
                    </div>
                </section>

                <section id="guvenlik">
                    <h2>🔒 9. Güvenlik ve En İyi Uygulamalar</h2>
                    
                    <h3>Private Key Yönetimi</h3>
                    <div class="warning-box">
                        <h4>⚠️ Kritik Güvenlik Uyarıları:</h4>
                        <ul>
                            <li>Private key'leri asla hardcode etmeyin</li>
                            <li>Environment variable'lar kullanın</li>
                            <li>Hardware wallet entegrasyonu tercih edin</li>
                            <li>Multi-signature cüzdan kullanın</li>
                            <li>Test network'te önce deneyin</li>
                        </ul>
                    </div>
                    
                    <div class="code-example">
                        <pre><code>import os
import keyring
from cryptography.fernet import Fernet
import hashlib

class SecureWalletManager:
    def __init__(self):
        self.fernet = None
        self.setup_encryption()
    
    def setup_encryption(self):
        """Şifreleme anahtarını kurma"""
        # Master password'dan key türet
        master_password = os.getenv('MASTER_PASSWORD')
        if not master_password:
            raise ValueError("MASTER_PASSWORD environment variable gerekli")
        
        # Deterministic key oluştur
        key = hashlib.pbkdf2_hmac(
            'sha256',
            master_password.encode(),
            b'salt_12345',  # Production'da random salt kullan
            100000
        )
        
        # Base64 encode et (Fernet için gerekli)
        key_b64 = base64.urlsafe_b64encode(key[:32])
        self.fernet = Fernet(key_b64)
    
    def store_private_key(self, account_name, private_key):
        """Private key'i güvenli şekilde sakla"""
        try:
            # Şifrele
            encrypted_key = self.fernet.encrypt(private_key.encode())
            
            # Sistem keyring'e kaydet
            keyring.set_password("blockchain_app", account_name, encrypted_key.decode())
            
            print(f"✅ {account_name} hesabı güvenli şekilde saklandı")
            return True
            
        except Exception as e:
            print(f"Saklama hatası: {e}")
            return False
    
    def load_private_key(self, account_name):
        """Private key'i güvenli şekilde yükle"""
        try:
            # Keyring'den al
            encrypted_key = keyring.get_password("blockchain_app", account_name)
            if not encrypted_key:
                raise ValueError("Hesap bulunamadı")
            
            # Şifreyi çöz
            decrypted_key = self.fernet.decrypt(encrypted_key.encode())
            
            return decrypted_key.decode()
            
        except Exception as e:
            print(f"Yükleme hatası: {e}")
            return None
    
    def create_secure_transaction(self, account_name, to_address, value, gas_limit=21000):
        """Güvenli transaction oluştur"""
        try:
            private_key = self.load_private_key(account_name)
            if not private_key:
                return None
            
            account = Account.from_key(private_key)
            
            # Nonce kontrolü
            nonce = self.w3.eth.get_transaction_count(account.address, 'pending')
            
            # Gas fiyatı optimizasyonu
            gas_price = self.get_optimal_gas_price()
            
            # Transaction oluştur
            transaction = {
                'to': to_address,
                'value': value,
                'gas': gas_limit,
                'gasPrice': gas_price,
                'nonce': nonce,
                'chainId': 1  # Mainnet
            }
            
            # İmzala
            signed_txn = account.sign_transaction(transaction)
            
            return signed_txn
            
        except Exception as e:
            print(f"Transaction oluşturma hatası: {e}")
            return None
    
    def get_optimal_gas_price(self):
        """Optimal gas fiyatını hesapla"""
        try:
            # Son 10 bloktaki gas fiyatlarını al
            latest_block = self.w3.eth.block_number
            gas_prices = []
            
            for i in range(10):
                block = self.w3.eth.get_block(latest_block - i, full_transactions=True)
                for tx in block.transactions[:5]:  # Her bloktan 5 transaction
                    if tx.gasPrice:
                        gas_prices.append(tx.gasPrice)
            
            if gas_prices:
                # Medyan gas fiyatını kullan
                gas_prices.sort()
                median_gas = gas_prices[len(gas_prices) // 2]
                
                # %10 premium ekle (hızlı onay için)
                optimal_gas = int(median_gas * 1.1)
                
                return optimal_gas
            else:
                # Fallback gas fiyatı
                return self.w3.to_wei(20, 'gwei')
                
        except Exception as e:
            print(f"Gas fiyat hesaplama hatası: {e}")
            return self.w3.to_wei(20, 'gwei')

class ContractAuditor:
    """Smart contract güvenlik denetimi"""
    
    def __init__(self, w3):
        self.w3 = w3
        self.vulnerability_patterns = {
            'reentrancy': [
                'call.value',
                'send(',
                'transfer(',
                'call.gas'
            ],
            'integer_overflow': [
                'SafeMath',
                'unchecked',
                '**'
            ],
            'access_control': [
                'onlyOwner',
                'require(msg.sender',
                'modifier'
            ]
        }
    
    def audit_contract(self, contract_address):
        """Contract'ı güvenlik açısından denetle"""
        try:
            # Contract kodunu al (verified contract'lar için)
            # Bu örnekte basitleştirilmiş
            
            audit_results = {
                'contract_address': contract_address,
                'audit_date': datetime.now().isoformat(),
                'vulnerabilities': [],
                'recommendations': [],
                'risk_score': 0
            }
            
            # Transaction pattern analizi
            recent_txs = self.analyze_transaction_patterns(contract_address)
            
            # Gas kullanım analizi
            gas_analysis = self.analyze_gas_usage(contract_address)
            
            # Event analizi
            event_analysis = self.analyze_events(contract_address)
            
            # Risk skoru hesapla
            risk_score = self.calculate_risk_score(recent_txs, gas_analysis, event_analysis)
            
            audit_results['risk_score'] = risk_score
            audit_results['transaction_analysis'] = recent_txs
            audit_results['gas_analysis'] = gas_analysis
            audit_results['event_analysis'] = event_analysis
            
            if risk_score > 70:
                audit_results['recommendations'].append("⚠️ Yüksek risk - contract kullanımına dikkat edin")
            elif risk_score > 40:
                audit_results['recommendations'].append("⚡ Orta risk - işlemlerinizi küçük miktarlarla test edin")
            else:
                audit_results['recommendations'].append("✅ Düşük risk - normal kullanım için güvenli görünüyor")
            
            return audit_results
            
        except Exception as e:
            print(f"Audit hatası: {e}")
            return None
    
    def calculate_risk_score(self, tx_analysis, gas_analysis, event_analysis):
        """Risk skorunu hesapla (0-100)"""
        score = 0
        
        # Transaction pattern riski
        if tx_analysis.get('failed_tx_rate', 0) > 0.05:  # %5'ten fazla başarısız tx
            score += 30
        
        # Gas kullanım riski
        if gas_analysis.get('avg_gas_usage', 0) > 500000:  # Yüksek gas kullanımı
            score += 20
        
        # Event pattern riski
        if event_analysis.get('unusual_events', 0) > 0:
            score += 25
        
        # Son aktivite riski
        if tx_analysis.get('last_activity_hours', 0) > 168:  # 1 haftadan fazla inaktif
            score += 15
        
        return min(score, 100)

# Kullanım
secure_wallet = SecureWalletManager()

# Private key'i güvenli sakla
secure_wallet.store_private_key("my_account", "0x...")

# Güvenli transaction oluştur
signed_tx = secure_wallet.create_secure_transaction(
    "my_account", 
    "0x...", 
    w3.to_wei(0.1, 'ether')
)

# Contract audit
auditor = ContractAuditor(w3)
audit_result = auditor.audit_contract("0x...")
print("Audit Sonucu:", audit_result)</code></pre>
                    </div>
                </section>

                <section id="gelecek-trendler">
                    <h2>🚀 10. 2025 Trendleri ve Gelecek</h2>
                    
                    <h3>Gelişen Teknolojiler</h3>
                    <div class="trend-grid">
                        <div class="trend-item">
                            <h4>🔗 Layer 2 Çözümleri</h4>
                            <p>Polygon, Arbitrum, Optimism gibi Layer 2 ağları Ethereum'un ölçeklenebilirlik sorunlarını çözerken, Python geliştiricileri için yeni fırsatlar yaratıyor.</p>
                            <ul>
                                <li>Düşük gas maliyetleri</li>
                                <li>Hızlı transaction onayları</li>
                                <li>Ethereum uyumluluğu</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>🌐 Cross-Chain Protokoller</h4>
                            <p>Farklı blockchain'ler arası köprü protokolleri, multi-chain uygulamalar için Python araçlarına ihtiyaç artırıyor.</p>
                            <ul>
                                <li>Bridge protokolleri</li>
                                <li>Cross-chain DEX'ler</li>
                                <li>Multi-chain portföy yönetimi</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>🤖 AI + Blockchain</h4>
                            <p>Yapay zeka ve blockchain'in birleşimi, Python'un güçlü AI kütüphaneleri ile önemli fırsatlar sunuyor.</p>
                            <ul>
                                <li>AI-powered trading botları</li>
                                <li>Prediction marketler</li>
                                <li>Decentralized AI servisleri</li>
                            </ul>
                        </div>
                        
                        <div class="trend-item">
                            <h4>🏛️ RWA Tokenization</h4>
                            <p>Real World Assets'lerin tokenleştirilmesi, Python ile veri entegrasyonu ve analizi gerektiriyor.</p>
                            <ul>
                                <li>Gayrimenkul tokenleştirilmesi</li>
                                <li>Commodity tokenları</li>
                                <li>Carbon credit tokenları</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3>Öğrenme Yol Haritası 2025</h3>
                    <div class="roadmap">
                        <div class="roadmap-step">
                            <h4>🎯 Başlangıç (1-2 ay)</h4>
                            <ul>
                                <li>Python temellerini pekiştirin</li>
                                <li>Web3.py kütüphanesini öğrenin</li>
                                <li>Testnet'te denemeler yapın</li>
                                <li>Basit wallet uygulaması geliştirin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>📈 Orta Seviye (3-4 ay)</h4>
                            <ul>
                                <li>Smart contract etkileşimlerini öğrenin</li>
                                <li>DeFi protokolleri ile çalışın</li>
                                <li>Basic trading bot geliştirin</li>
                                <li>NFT projelerini keşfedin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>🚀 İleri Seviye (5-6 ay)</h4>
                            <ul>
                                <li>Cross-chain uygulamalar geliştirin</li>
                                <li>Advanced arbitraj sistemleri</li>
                                <li>Yield farming optimizasyonu</li>
                                <li>MEV botları geliştirin</li>
                            </ul>
                        </div>
                        
                        <div class="roadmap-step">
                            <h4>💎 Uzman Seviye (6+ ay)</h4>
                            <ul>
                                <li>Kendi DeFi protokolünüzü geliştirin</li>
                                <li>AI-powered blockchain uygulamaları</li>
                                <li>Institutional trading sistemleri</li>
                                <li>Blockchain consulting hizmetleri</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3>Tavsiye Edilen Kaynaklar</h3>
                    <div class="resources-grid">
                        <div class="resource-item">
                            <h4>📚 Kütüphaneler</h4>
                            <ul>
                                <li><strong>Web3.py:</strong> Ethereum etkileşimi</li>
                                <li><strong>Brownie:</strong> Smart contract development</li>
                                <li><strong>eth-account:</strong> Account management</li>
                                <li><strong>pycoingecko:</strong> Fiyat verileri</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>🔧 Araçlar</h4>
                            <ul>
                                <li><strong>Hardhat:</strong> Development framework</li>
                                <li><strong>Remix:</strong> Online IDE</li>
                                <li><strong>MetaMask:</strong> Browser wallet</li>
                                <li><strong>Etherscan:</strong> Blockchain explorer</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>🌐 Platformlar</h4>
                            <ul>
                                <li><strong>OpenZeppelin:</strong> Secure contracts</li>
                                <li><strong>Uniswap:</strong> DEX protokolü</li>
                                <li><strong>Aave:</strong> Lending protokolü</li>
                                <li><strong>OpenSea:</strong> NFT marketplace</li>
                            </ul>
                        </div>
                        
                        <div class="resource-item">
                            <h4>📖 Eğitim</h4>
                            <ul>
                                <li><strong>CryptoZombies:</strong> Game-based learning</li>
                                <li><strong>Consensys Academy:</strong> Professional courses</li>
                                <li><strong>Ethereum.org:</strong> Official documentation</li>
                                <li><strong>DeFi Pulse:</strong> Market insights</li>
                            </ul>
                        </div>
                    </div>
                </section>
            </div>

            <!-- Article Footer -->
            <footer class="article-footer">
                <div class="article-tags">
                    <h4>🏷️ Etiketler:</h4>
                    <span class="tag">#python</span>
                    <span class="tag">#blockchain</span>
                    <span class="tag">#web3</span>
                    <span class="tag">#defi</span>
                    <span class="tag">#nft</span>
                    <span class="tag">#ethereum</span>
                    <span class="tag">#smart-contracts</span>
                    <span class="tag">#crypto</span>
                </div>
                
                <div class="share-buttons">
                    <h4>📤 Paylaş:</h4>
                    <a href="#" class="share-btn twitter">Twitter</a>
                    <a href="#" class="share-btn linkedin">LinkedIn</a>
                    <a href="#" class="share-btn facebook">Facebook</a>
                    <a href="#" class="share-btn copy">Link Kopyala</a>
                </div>
                
                <div class="author-info">
                    <h4>✍️ Yazar Hakkında</h4>
                    <p>Bu makale Python ve blockchain teknolojileri konusunda deneyimli geliştiriciler tarafından hazırlanmıştır. En güncel bilgiler ve pratik örneklerle blockchain dünyasına giriş yapmanızı kolaylaştırmayı hedefliyoruz.</p>
                </div>
            </footer>
        </article>

        <!-- Related Articles -->
        <section class="related-articles">
            <h3>📖 İlgili Makaleler</h3>
            <div class="related-grid">
                <article class="related-card">
                    <h4><a href="python-ile-para-kazanma-15-yontem-2025.html">💰 Python ile Para Kazanma: 15 Farklı Yöntem</a></h4>
                    <p>Python bilginizi paraya çevirmenin kanıtlanmış yöntemleri</p>
                </article>
                <article class="related-card">
                    <h4><a href="chatgpt-ile-python-kodlama-ai-destekli-programlama.html">🤖 ChatGPT ile Python Kodlama</a></h4>
                    <p>AI destekli programlama teknikleri ve ipuçları</p>
                </article>
                <article class="related-card">
                    <h4><a href="../web-dev/web3-ve-blockchain-integration.html">🌐 Web3 ve Blockchain Entegrasyonu</a></h4>
                    <p>Modern web uygulamalarında blockchain kullanımı</p>
                </article>
            </div>
        </section>
    </main>

    <!-- Sidebar Ad -->
    <aside class="sidebar">
        <div class="ad-zone-sidebar">
            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="2077956392" data-ad-format="auto" data-full-width-responsive="true"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
    </aside>

    <!-- Footer Ad -->
    <div class="ad-zone-footer">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9023802833968711" data-ad-slot="9486093631" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <!-- JavaScript -->
    <script>
        // Smooth scrolling for table of contents
        document.querySelectorAll('.table-of-contents a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Copy code functionality
        document.querySelectorAll('.code-example').forEach(codeBlock => {
            const copyBtn = document.createElement('button');
            copyBtn.textContent = '📋 Kopyala';
            copyBtn.className = 'copy-btn';
            
            copyBtn.addEventListener('click', () => {
                const code = codeBlock.querySelector('code').textContent;
                navigator.clipboard.writeText(code).then(() => {
                    copyBtn.textContent = '✅ Kopyalandı!';
                    setTimeout(() => {
                        copyBtn.textContent = '📋 Kopyala';
                    }, 2000);
                });
            });
            
            codeBlock.appendChild(copyBtn);
        });

        // Share functionality
        document.querySelectorAll('.share-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const url = window.location.href;
                const title = document.title;
                
                if (this.classList.contains('twitter')) {
                    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(title)}&url=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('linkedin')) {
                    window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('facebook')) {
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`);
                } else if (this.classList.contains('copy')) {
                    navigator.clipboard.writeText(url).then(() => {
                        this.textContent = '✅ Kopyalandı!';
                        setTimeout(() => {
                            this.textContent = 'Link Kopyala';
                        }, 2000);
                    });
                }
            });
        });

        // Reading progress bar
        const progressBar = document.createElement('div');
        progressBar.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, #ef4444, #f97316);
            z-index: 9999;
            transition: width 0.3s ease;
        `;
        document.body.appendChild(progressBar);

        window.addEventListener('scroll', () => {
            const article = document.querySelector('.article-content');
            const articleHeight = article.offsetHeight;
            const windowHeight = window.innerHeight;
            const scrolled = window.scrollY;
            const articleStart = article.offsetTop;
            const articleEnd = articleStart + articleHeight - windowHeight;
            
            if (scrolled >= articleStart && scrolled <= articleEnd) {
                const progress = ((scrolled - articleStart) / (articleEnd - articleStart)) * 100;
                progressBar.style.width = Math.min(100, Math.max(0, progress)) + '%';
            }
        });
    </script>

    <!-- AdSense Optimization -->
    <script src="../../adsense-optimization.js"></script>
    
    <!-- Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-40X5D8K6WH"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-40X5D8K6WH');
    </script>
</body>
</html>