<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Container Tutorial - Containerization Rehberi</title>
    <meta name="description" content="Docker ile containerization Ã¶ÄŸrenin. Dockerfile yazma, image oluÅŸturma, container yÃ¶netimi ve best practices.">
    <meta name="keywords" content="docker, containerization, dockerfile, devops, microservices">
    <link rel="stylesheet" href="../blog-styles.css">
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="/" class="logo">ğŸš€ AI & Python EÄŸitimi</a>
            <ul class="nav-menu">
                <li><a href="/">Ana Sayfa</a></li>
                <li><a href="/blog/">Blog</a></li>
                <li><a href="/python-kursu.html">Python Kursu</a></li>
                <li><a href="/veri-analizi.html">Veri Analizi</a></li>
                <li><a href="/yapay-zeka-rehberi.html">AI Rehberi</a></li>
            </ul>
        </div>
    </nav>

    <article class="blog-post">
        <header class="post-header">
            <div class="post-meta">
                <span class="category">ğŸ“š Tutorial</span>
                <time datetime="2025-08-19">19 AÄŸustos 2025</time>
                <span class="read-time">â±ï¸ 35 dakika okuma</span>
            </div>
            <h1>Docker Container Tutorial - Containerization Rehberi</h1>
            <p class="lead">Docker ile containerization teknolojisini Ã¶ÄŸrenin ve modern geliÅŸtirme sÃ¼reÃ§lerini optimize edin</p>
        </header>

        <div class="post-content">
            <h2>Docker Nedir?</h2>
            <p>Docker, uygulamalarÄ± container'larda paketlemek ve Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lan bir platformdur. Container'lar uygulamanÄ±zÄ± tÃ¼m dependencies'leri ile birlikte paketler ve her ortamda tutarlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.</p>

            <h2>Docker'Ä±n AvantajlarÄ±</h2>
            <ul>
                <li><strong>Portability:</strong> Herhangi bir ortamda Ã§alÄ±ÅŸÄ±r</li>
                <li><strong>Consistency:</strong> Dev, test ve production aynÄ± environment</li>
                <li><strong>Scalability:</strong> Kolay Ã¶lÃ§eklendirme</li>
                <li><strong>Resource Efficiency:</strong> VM'lere gÃ¶re daha az kaynak kullanÄ±r</li>
                <li><strong>Fast Deployment:</strong> HÄ±zlÄ± baÅŸlatma ve durdurma</li>
            </ul>

            <h2>1. Docker Kurulumu</h2>
            
            <h3>Windows</h3>
            <pre><code># Docker Desktop'Ä± indirin ve kurun
# https://www.docker.com/products/docker-desktop

# WSL 2 backend gerekli (Windows 10/11)
wsl --install
wsl --set-default-version 2</code></pre>

            <h3>macOS</h3>
            <pre><code># Docker Desktop'Ä± indirin ve kurun
# https://www.docker.com/products/docker-desktop

# Homebrew ile
brew install --cask docker</code></pre>

            <h3>Ubuntu/Linux</h3>
            <pre><code># Official Docker repository ekle
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Docker'Ä± kur
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io

# User'Ä± docker grubuna ekle
sudo usermod -aG docker $USER</code></pre>

            <h3>Kurulum Testi</h3>
            <pre><code># Docker version kontrol
docker --version
docker-compose --version

# Test container Ã§alÄ±ÅŸtÄ±r
docker run hello-world</code></pre>

            <h2>2. Temel Docker KomutlarÄ±</h2>

            <h3>Image YÃ¶netimi</h3>
            <pre><code># Image'leri listele
docker images
docker image ls

# Image indir
docker pull nginx:latest
docker pull python:3.9

# Image sil
docker rmi image_name:tag
docker rmi image_id

# KullanÄ±lmayan image'leri temizle
docker image prune</code></pre>

            <h3>Container YÃ¶netimi</h3>
            <pre><code># Container Ã§alÄ±ÅŸtÄ±r
docker run nginx
docker run -d nginx                    # Detached mode
docker run -p 8080:80 nginx           # Port mapping
docker run --name my-nginx nginx      # Container ismi ver

# Ã‡alÄ±ÅŸan container'larÄ± listele
docker ps
docker container ls

# TÃ¼m container'larÄ± listele (durmuÅŸ olanlar dahil)
docker ps -a

# Container durdur
docker stop container_name
docker stop container_id

# Container baÅŸlat
docker start container_name

# Container sil
docker rm container_name
docker rm container_id

# Ã‡alÄ±ÅŸan container'Ä± sil
docker rm -f container_name</code></pre>

            <h3>Container Ä°nteraksiyon</h3>
            <pre><code># Container iÃ§ine bash ile gir
docker exec -it container_name bash
docker exec -it container_name sh

# Container loglarÄ±nÄ± gÃ¶rÃ¼ntÃ¼le
docker logs container_name
docker logs -f container_name  # Follow mode

# Container resource kullanÄ±mÄ±nÄ± gÃ¶rÃ¼ntÃ¼le
docker stats
docker stats container_name</code></pre>

            <h2>3. Dockerfile Yazma</h2>
            <p>Dockerfile, Docker image'Ä± nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± tanÄ±mlayan text dosyasÄ±dÄ±r.</p>

            <h3>Basit Python UygulamasÄ±</h3>
            <pre><code># app.py
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, Docker!'

@app.route('/health')
def health():
    return {'status': 'healthy'}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)</code></pre>

            <pre><code># requirements.txt
Flask==2.3.2</code></pre>

            <pre><code># Dockerfile
FROM python:3.9-slim

# Working directory ayarla
WORKDIR /app

# Requirements dosyasÄ±nÄ± kopyala ve install et
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Uygulama dosyalarÄ±nÄ± kopyala
COPY . .

# Port expose et
EXPOSE 5000

# Health check ekle
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Uygulama Ã§alÄ±ÅŸtÄ±r
CMD ["python", "app.py"]</code></pre>

            <h3>Image Build Etme</h3>
            <pre><code># Image build et
docker build -t my-flask-app .
docker build -t my-flask-app:v1.0 .

# Build cache kullanmadan
docker build --no-cache -t my-flask-app .

# Multi-stage build example
# Dockerfile.multi-stage</code></pre>

            <h3>Multi-stage Build</h3>
            <pre><code># Multi-stage Dockerfile (Node.js Ã¶rneÄŸi)
# Build stage
FROM node:16-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine

# Build stage'den sadece gerekli dosyalarÄ± kopyala
COPY --from=builder /app/dist /usr/share/nginx/html

# Nginx config
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]</code></pre>

            <h2>4. Docker Compose</h2>
            <p>Docker Compose, multi-container uygulamalarÄ± tanÄ±mlamak ve Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.</p>

            <h3>docker-compose.yml</h3>
            <pre><code># docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/myapp
      - REDIS_URL=redis://redis:6379
    volumes:
      - .:/app
    networks:
      - app-network

  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

  redis:
    image: redis:6-alpine
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web
    networks:
      - app-network

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge</code></pre>

            <h3>Docker Compose KomutlarÄ±</h3>
            <pre><code># Servisleri baÅŸlat
docker-compose up
docker-compose up -d        # Detached mode
docker-compose up --build  # Build ile baÅŸlat

# Belirli servisi baÅŸlat
docker-compose up web

# Servisleri durdur
docker-compose down
docker-compose down -v      # Volume'leri de sil

# LoglarÄ± gÃ¶rÃ¼ntÃ¼le
docker-compose logs
docker-compose logs web
docker-compose logs -f web  # Follow mode

# Servislerin durumunu gÃ¶ster
docker-compose ps

# Servis scale et
docker-compose up --scale web=3</code></pre>

            <h2>5. Docker Volumes</h2>
            <p>Volumes, container'lardaki veriyi persist etmek iÃ§in kullanÄ±lÄ±r.</p>

            <h3>Volume TÃ¼rleri</h3>
            <pre><code># Named Volume
docker volume create my-vol
docker run -d -v my-vol:/app/data nginx

# Bind Mount (Host path'i container'a mount et)
docker run -d -v /host/path:/container/path nginx
docker run -d -v $(pwd):/app python:3.9

# Anonymous Volume
docker run -d -v /app/data nginx</code></pre>

            <h3>Volume YÃ¶netimi</h3>
            <pre><code># Volume'leri listele
docker volume ls

# Volume detaylarÄ±nÄ± gÃ¶ster
docker volume inspect volume_name

# Volume oluÅŸtur
docker volume create my-data

# Volume sil
docker volume rm volume_name

# KullanÄ±lmayan volume'leri temizle
docker volume prune</code></pre>

            <h2>6. Docker Networks</h2>
            <p>Container'lar arasÄ± iletiÅŸimi saÄŸlamak iÃ§in network'ler kullanÄ±lÄ±r.</p>

            <h3>Network TÃ¼rleri</h3>
            <pre><code># Bridge Network (default)
docker network create my-bridge-network
docker run -d --network my-bridge-network --name web1 nginx
docker run -d --network my-bridge-network --name web2 nginx

# Host Network
docker run -d --network host nginx

# None Network (no networking)
docker run -d --network none nginx</code></pre>

            <h3>Network YÃ¶netimi</h3>
            <pre><code># Network'leri listele
docker network ls

# Network detaylarÄ±nÄ± gÃ¶ster
docker network inspect network_name

# Network oluÅŸtur
docker network create --driver bridge my-network

# Container'Ä± network'e baÄŸla
docker network connect network_name container_name

# Container'Ä± network'ten ayÄ±r
docker network disconnect network_name container_name

# Network sil
docker network rm network_name</code></pre>

            <h2>7. Docker Registry</h2>

            <h3>Docker Hub</h3>
            <pre><code># Docker Hub'a login
docker login

# Image'Ä± tag'le
docker tag my-app:latest username/my-app:latest
docker tag my-app:latest username/my-app:v1.0

# Image'Ä± push et
docker push username/my-app:latest
docker push username/my-app:v1.0

# Image'Ä± pull et
docker pull username/my-app:latest</code></pre>

            <h3>Private Registry</h3>
            <pre><code># Local registry Ã§alÄ±ÅŸtÄ±r
docker run -d -p 5000:5000 --restart=always --name registry registry:2

# Image'Ä± local registry'ye push et
docker tag my-app:latest localhost:5000/my-app:latest
docker push localhost:5000/my-app:latest

# Local registry'den pull et
docker pull localhost:5000/my-app:latest</code></pre>

            <h2>8. Docker Best Practices</h2>

            <h3>Dockerfile Best Practices</h3>
            <pre><code># âœ… Ä°yi practices
FROM python:3.9-slim

# Non-root user oluÅŸtur
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Working directory
WORKDIR /app

# Dependencies'leri Ã¶nce kopyala (cache iÃ§in)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Uygulama dosyalarÄ±nÄ± kopyala
COPY . .

# Ownership deÄŸiÅŸtir
RUN chown -R appuser:appuser /app
USER appuser

# Specific port expose et
EXPOSE 8000

# Health check ekle
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Signal handling iÃ§in exec form kullan
CMD ["python", "-m", "uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>

            <h3>.dockerignore</h3>
            <pre><code># .dockerignore
node_modules
npm-debug.log
Dockerfile
.dockerignore
.git
.gitignore
README.md
.env
.nyc_output
coverage
.nyc_output
.coverage
.pytest_cache
__pycache__</code></pre>

            <h3>Security Best Practices</h3>
            <pre><code># âŒ Root user kullanma
USER root

# âœ… Non-root user kullan
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser

# âŒ Latest tag kullanma
FROM python:latest

# âœ… Specific version kullan
FROM python:3.9.16-slim

# âŒ TÃ¼m port'larÄ± expose etme
EXPOSE 0-65535

# âœ… Sadece gerekli port'u expose et
EXPOSE 8000</code></pre>

            <h2>9. Container Monitoring</h2>

            <h3>Resource Monitoring</h3>
            <pre><code># Container resource kullanÄ±mÄ±
docker stats

# Belirli container
docker stats container_name

# Memory limit koy
docker run -d --memory="256m" nginx

# CPU limit koy
docker run -d --cpus="1.5" nginx

# Container processes
docker exec container_name ps aux</code></pre>

            <h3>Logging</h3>
            <pre><code># Log driver ayarla
docker run -d --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 nginx

# Log gÃ¶rÃ¼ntÃ¼le
docker logs container_name
docker logs --tail 50 container_name
docker logs --since="2023-01-01T00:00:00" container_name

# Log export et
docker logs container_name > container_logs.txt</code></pre>

            <h2>10. Production Ready Setup</h2>

            <h3>Multi-stage Production Build</h3>
            <pre><code># Dockerfile.prod
FROM python:3.9-slim as builder

WORKDIR /app
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

FROM python:3.9-slim

# Security: non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Copy dependencies from builder
COPY --from=builder /root/.local /home/appuser/.local

WORKDIR /app
COPY . .
RUN chown -R appuser:appuser /app

USER appuser

# Make sure scripts in .local are usable
ENV PATH=/home/appuser/.local/bin:$PATH

EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:app"]</code></pre>

            <h3>Production docker-compose.yml</h3>
            <pre><code># docker-compose.prod.yml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.prod
    restart: unless-stopped
    expose:
      - "8000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - SECRET_KEY=${SECRET_KEY}
    networks:
      - app-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.prod.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - web
    networks:
      - app-network

  db:
    image: postgres:13
    restart: unless-stopped
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

volumes:
  postgres_data:
    driver: local

networks:
  app-network:
    driver: bridge</code></pre>

            <h2>11. Troubleshooting</h2>

            <h3>YaygÄ±n Problemler ve Ã‡Ã¶zÃ¼mleri</h3>
            <pre><code># Container baÅŸlamÄ±yor
docker logs container_name
docker exec -it container_name sh

# Port conflicts
docker ps -a  # KullanÄ±lan port'larÄ± kontrol et
docker run -p 8080:80 nginx  # FarklÄ± port kullan

# Volume mount problems
docker inspect container_name  # Volume mount'larÄ± kontrol et
docker run -v $(pwd):/app alpine ls /app  # Mount test et

# Network connectivity
docker network inspect bridge
docker exec container1 ping container2

# Resource issues
docker system df  # Disk usage
docker system prune  # Cleanup unused resources</code></pre>

            <h3>Debug Commands</h3>
            <pre><code># Container iÃ§indeki processes
docker exec container_name ps aux

# Container file system
docker exec container_name ls -la
docker exec container_name df -h

# Network test
docker exec container_name ping google.com
docker exec container_name netstat -tuln

# Environment variables
docker exec container_name env</code></pre>

            <h2>SonuÃ§</h2>
            <p>Bu tutorial'da Docker'Ä±n temellerinden production-ready deployment'a kadar geniÅŸ bir yelpazede konularÄ± ele aldÄ±k. Docker modern yazÄ±lÄ±m geliÅŸtirmenin vazgeÃ§ilmez bir parÃ§asÄ± haline gelmiÅŸtir.</p>

            <h3>Ã–nemli Noktalar:</h3>
            <ul>
                <li>Container'lar VM'lerden daha hafif ve hÄ±zlÄ±dÄ±r</li>
                <li>Dockerfile best practices'lerini takip edin</li>
                <li>Security iÃ§in non-root user kullanÄ±n</li>
                <li>Multi-stage build ile image size'Ä± optimize edin</li>
                <li>Production'da proper logging ve monitoring yapÄ±n</li>
                <li>Docker Compose ile multi-container uygulamalarÄ± yÃ¶netin</li>
            </ul>

            <p>Docker'Ä± Ã¶ÄŸrenmek iÃ§in en iyi yol practice yapmaktÄ±r. Kendi uygulamalarÄ±nÄ±zÄ± containerize ederek deneyim kazanÄ±n!</p>
        </div>
    </article>
</body>
</html>